<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数仓概览</title>
      <link href="2020/07/30/data-warehouse.html"/>
      <url>2020/07/30/data-warehouse.html</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ol><li>为什么要分层<ol><li>把复杂问题简单化<ol><li>将复杂的任务分解成多层来完成，每一层指处理简单的任务，方便定位问题</li></ol></li><li>减少重复开发<ol><li>规范数据分层，通过中间数据层，极大的减少重复计算，增加一次计算结果的复用性</li></ol></li><li>隔离原始数据<ol><li>真实数据与统计数据解偶开</li></ol></li></ol></li><li>维度建模<ol><li>星型模型<ol><li>维度只有一层</li></ol></li><li>雪花模型<ol><li>维度会有多层</li></ol></li></ol></li><li>分层<ol><li>ODS (Operation Data Store)<ol><li>原始数据层，保持数据原貌，不做处理</li><li>压缩存储</li><li>分区表，避免全表查询</li><li>Hive 内部表和外部表的区别<ol><li>删除内部表，会把元数据和原始数据全删除</li><li>删除内部表，只删除元数据，原始数据保留</li></ol></li></ol></li><li>DWD (Data Warehouse Detail)<ol><li>结构和粒度与原始表保持一致，对 ODS 层进行清洗</li><li>选择业务过程-》声明粒度-》确认维度-》确认事实</li></ol></li><li>DWS (Data Warehouse Service)<ol><li>以DWD为基础，按天进行轻度汇总</li></ol></li><li>DWT (Data Warehouse Topic)<ol><li>以DWS为基础，按主题进行汇总</li></ol></li><li>ADS (Application Data Store)<ol><li>为各种统计报表提供数据</li></ol></li></ol></li></ol><h2 id="数仓技术组件"><a href="#数仓技术组件" class="headerlink" title="数仓技术组件"></a>数仓技术组件</h2><ol><li>数据传输采集<ol><li>kafka, Flume, Sqoop, datax</li></ol></li><li>数据存储：<ol><li>mysql，hdfs，hbase</li></ol></li><li>数据计算<ol><li>hive，tez on hive， spark，flink</li></ol></li><li>数据查询<ol><li>Presto</li><li>Druid</li><li>Impala</li><li>Kylin</li></ol></li><li>数据可视化<ol><li>Echarts，QuickBI，DataV</li></ol></li><li>任务调度<ol><li>Azkaban，Oozie + CDH</li></ol></li><li>集群监控<ol><li>Zabbix</li></ol></li><li>元数据管理<ol><li>Atlas</li></ol></li><li>数据质量监控<ol><li>Griffin</li></ol></li></ol><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ol><li>数据仓库工具箱—维度建模权威指南</li></ol>]]></content>
      
      
      <categories>
          
          <category> big-data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> big-data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 吞吐为什么高</title>
      <link href="2020/07/02/why-kafka-so-fast.html"/>
      <url>2020/07/02/why-kafka-so-fast.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kafka 是一个分布式流处理平台。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li><strong>消息系统：</strong>消息队列解耦生产者和消费者等</li><li><strong>流式处理：</strong>以高容错，低延迟的方式存储，处理实时流式数据</li><li>**存储系统: **数据存储在磁盘上</li></ul><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><img data-original="why-kafka-so-fast/architecture.png" class="lazy" alt="kafka-archicture" src="/images/squares.svg"><h2 id="设计要点"><a href="#设计要点" class="headerlink" title="设计要点"></a>设计要点</h2><ol><li>topic and partition<ol><li>producer 发送到 kafka server 的消息以 topic 分组，consumer 可以按照 topic 来订阅消费某类型的消息数据</li><li>topic 在 kafka server 内细分多个 partition 存储消息，每个消息在 partition 内部都是有序的，并且会有个 位置标识，也叫 offset</li><li>每个 consumer 消费消息的同时，会往metadata 里面存储当前 consumer 消费过的消息的 offset。这也使得 consumer 可以从任意的 offset 来消费消息，并且多个消费者之间是互不影响的</li></ol></li><li>顺序读写，提高硬盘的读写速度<ol><li>硬盘是机械结构，每次读写都会 寻址 → 写入，寻址是一个耗时的动作，顺序写入寻址的时间会比随机写入快的多</li><li>topic 里的每个 partition 其实都是一个文件，kafka 将消息顺序存储 append 到 partition 文件的末尾</li></ol></li><li>Memory Mapped Files (mmap)<ol><li>即使是顺序写入磁盘，硬盘的访问速度也比不上内存。所以kafka 的数据并不是实时的写入磁盘。它充分利用了现代操作系统 page cache 来利用内存提高I/O效率。</li><li>mmap(内存映射文件)，在64位操作系统中一般可以表示20G的数据文件，它的工作原理是直接利用操作系统的Page来实现文件到物理内存的直接映射。完成映射之后你对物理内存的操作会被同步到硬盘上（操作系统在适当的时候）。</li><li>通过mmap，进程像读写硬盘一样读写内存（当然是虚拟机内存），也不必关心内存的大小有虚拟内存为我们兜底。但也有一个很明显的缺陷——不可靠，写到mmap中的数据并没有被真正的写到硬盘，操作系统会在程序主动调用flush的时候才把数据真正的写到硬盘。</li></ol></li><li>采用 Zero-Copy 提高发送性能<ol><li>传统read/write方式进行网络文件传输的方式<br> 硬盘—&gt;内核buf—&gt;用户buf—&gt;socket相关缓冲区—&gt;协议引擎</li><li>Zero-Copy 利用 sendfile 则减少多次copy拷贝，提升文件传输性能<br> 硬盘—&gt;内核buf—&gt;socket相关缓冲区—&gt;协议引擎</li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>kafka 可以定位成一个文件存储系统</p><ul><li>producer 发送的数据 可以被 topic + partition 分散到多个存储路径</li><li>cosumer 通过在 zokeeper 维护数据消费的 offset，可以从 kafka 任意位置开始，读取有序的数据</li><li>数据的读取和写入不会互相阻塞，性能可以永远达到最大化</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM GC 调参 AND 调优</title>
      <link href="2020/06/18/jvm-gc-tunning.html"/>
      <url>2020/06/18/jvm-gc-tunning.html</url>
      
        <content type="html"><![CDATA[<h2 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h2><p>Java 中在一小段代码中大量的对象被快速地创建和丢弃，这种操作是非常普遍的。</p><p>垃圾收集器设计时特别考虑要处理大量（有时候是大多数）临时对象，这是分代设计的初衷之一。</p><ul><li>新生代<ul><li>对象首先在新生代中分配。新生代填满时，垃圾收集器会暂停所有的应用线程，回收新生代空间。不再使用的对象会被回收，仍然在使用的对象会被移动到其他地方。这种操作被称为 Minor GC，又称 Young GC。</li><li>采用这种设计有两个性能上的优势<ul><li>新生代仅是堆的一部分，与处理整个堆相比，处理新生代的速度要更快，也就意味着应用线程停顿的时间会更短</li><li>新生代分为 Eden 区 和两个 Survivor 空间，新生代的对象起初都分配在 Eden 区，垃圾收集时，Eden 区的对象要么被回收，要么就被移动到老年代，要么被移动到 Survivor 空间(两个 Survivor 空间会来回倒换不能被回收的对象，当超过一定的倒换次数，才会被挪到老年代)，这样相当于给新生代做了一次压缩整理</li></ul></li></ul></li><li>老年代<ul><li>新生代回收之后的依然存活的对象不断的挪到老年代，老年代就会被填满。JVM 就需要对整个堆进行垃圾回收，这个过程被成为 FullGC。</li></ul></li></ul><h2 id="GC-算法"><a href="#GC-算法" class="headerlink" title="GC 算法"></a>GC 算法</h2><ol><li>Serial 垃圾收集器<ul><li>使用单线程清理堆的内容。</li><li>无论是 Minor GC 还是 Full GC，清理堆空间时，所有线程都会被暂停。</li><li>进行 Full GC 时，还会对老年代空间的对象进行压缩整理。</li><li>通过 -XX:+UseSerialGC 标志可以启用 Serial 收集器</li></ul></li><li>Parallel 垃圾收集器，也叫 Throughput 收集器<ul><li>多线程回收新生代和老年代，Minor GC 的速度要比 Serial 收集器快的多。</li><li>Minor GC 和 Full GC 的时候，会暂停所有线程，Full GC 也会对老年代进行压缩整理</li><li>通过 -XX:+UserParallelGC -XX:UseParallelOldGC 启用 Parallel 收集器</li></ul></li><li>CMS 收集器<ul><li>CMS 设计初衷是为了降低 Full GC 周期中的长时间停顿。</li><li>Minor GC 会暂停所有线程，并以多线程的方式进行垃圾回收。</li><li>使用若干个后台线程定期的对老年代空间进行扫描，通过 标记，清除等操作及时回收其中不再使用的对象。这种算法使 CMS 成为一个低延迟的收集器，应用线程仅在 Minor GC 以及后台扫描老年代时发生极其短暂的停顿，比起 Parallel 停顿总时长要短的多</li><li>额外付出的时更高的 CPU 使用，CMS 要求必须要有足够的 CPU 资源用于运行后台的垃圾收集线程</li><li>回收线程不进行任何压缩整理的工作，这意味着堆会逐渐变得碎片化。如果 CMS 的后台线程无法获得任务所需的 CPU 资源，或者堆变得过度碎片化以至于无法找到连续空间分配对象，CMS 就会蜕化到 Serial 收集器的行为：暂停所有应用线程，单线程回收，整理老年代空间。之后有恢复到并发运行，再次启动后台线程（直到下一次堆变得过度碎片化）</li><li>通过 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC 启用 CMS 收集器</li></ul></li><li>G1 垃圾收集器<ul><li>G1 设计初衷是为了尽量缩短处理超大堆（大于 4GB）时产生的停顿。</li><li>G1 算法将堆划分为若干个区域（Region），不过它依然属于分代收集器。利用多线程的方式来收集新生代和老年代</li><li>G1 算法属于 Concurrent 收集器。老年代的垃圾收集工作由后台线程完成，不需要暂停应用线程</li><li>G1 将老年代划分成不同的区域（Region），通过将对象从一个区域复制到另一个区域，完成对象的清理工作，也同时实现了堆的压缩整理，所以 G1 收集的堆不太容易发生碎片化</li><li>同 CMS 一样，避免 Full GC 的代价就是消耗额外的 CPU 周期</li><li>通过 -XX:+UseG1 启用 G1 收集器</li></ul></li></ol><h2 id="GC-算法选择"><a href="#GC-算法选择" class="headerlink" title="GC 算法选择"></a>GC 算法选择</h2><ul><li>如果应用线程可以最大程度的利用 CPU，使用 Parallel 通常能获得更好的性能</li><li>如果应用线程没有充分利用 CPU，则使用 Concurrent 往往能获得更好的性能</li><li>选择 Concurrent ，如果堆较小，推荐使用 CMS ，G1 的设计使得它能够在不同的分区（Region）处理堆，因此 G1 比 CMS 更易于处理超大堆的情况</li></ul><h2 id="GC-调优基础"><a href="#GC-调优基础" class="headerlink" title="GC 调优基础"></a>GC 调优基础</h2><ul><li><p>调整堆的大小</p><ul><li>不要将堆的容量设置得比机器的物理内存还大，通常情况下，至少要预留 1G 的内存空间</li><li>尽量通过调整 GC 算法进行调优，而不是调整堆的大小来改善程序性能</li></ul></li><li><p>代空间的调整</p><ul><li>整个堆的范围内，不同代的大小划分是由新生代所占用的空间控制的</li><li>-XX:NewRatio=N 设置新生代与老年代的空间占用比率</li><li>-XX:NewSize=N 设置新生代空间的初始大小</li><li>-XX:MaxNewSize=N 设置新生代空间的最大值</li><li>-XmnN 将 newSize 和 MaxNewSize 设定为同一个值的快捷方法</li></ul></li><li><p>永久代和元空间的调整</p><ul><li>Jdk7 中的永久代和 jdk8 中的元空间保存着类的元数据</li><li>永久代或元空间耗尽也会触发 Full GC，这时老的元数据会被丢弃回收</li></ul></li><li><p>控制 GC 并发线程的数量</p><ul><li><p>几乎所有的垃圾收集算法的回收线程数都依据机器上的 CPU 数据算出<br>N 为 CPU 的数目，每个 CPU 最多同时运行 8 个线程</p><p>$$ParallelGCThreads = 8 + ((N - 8) * 5 / 8)$$</p></li></ul></li><li><p>JVM 自适应调整</p><ul><li>JVM 默认会自适应的调整新生代和老年代的百分比</li><li>对于已经精细化调优过的堆，使用 -XX:-UseAdaptiveSizePolicy 可以在全局范围内关闭自适应调整</li></ul></li><li><p>垃圾回收工具</p><ul><li>-verbose:gc 或 -XX:+PrintGC 这两个标志中的任意一个都能创建基本的 GC 日志</li><li>使用 -XX:PrintGCDetails 可以创建更详细的 GC 日志</li><li>使用 -XX:+PrintGCTimeStamps 或 -XX:+PrintGCDateStamps 可以更精确的判断几次 GC 操作之间的时间</li><li>使用 jstat -gccause PID 1000 10 可以监控应用程序的垃圾回收过程</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://union-click.jd.com/jdc?e=&p=AyIGZRhYFAEbBVAaUxYyEgdcE1wdCxs3EUQDS10iXhBeGlcJDBkNXg9JHU4YDk5ER1xOGRNLGEEcVV8BXURFUFdfC0RVU1JRUy1OVxUCGw9SE1IcMkEFKBsgdllyZ1VHA0tgYXIzaDppeGILWStaJQITBlUTWhUFFAVlK1sSMkBpja3tzaejG4Gx1MCKhTdUK1sRChECXBNfEwQSAVIrXBULIlAFTA9KWUpYA0g1STIiN1YrayUCIgRlWTURChAHVh0LHVBCBlYeUhMEGgUCSQ9BVxQEURoJR1IaBWUZWhQGGw==">Java 性能指南</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome Driver 破解反爬</title>
      <link href="2020/01/13/make-chromedriver-undetectable.html"/>
      <url>2020/01/13/make-chromedriver-undetectable.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>过年回家买机票，各个机票网站上的价格都稍有差别，于是就利用 <a href="https://github.com/wtog/web-crawler">web-crawler</a> 爬一爬<br>过程中发现，爬取 qunar 的信息时，qunar 识别了 chrome headless，故意返回了错误的数据<br>这时只能面向 Google 编程了</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>理论上，selenium+chromedriver 是可以完全模拟真是浏览器的<br>但是实际上 chromedriver 在启动的时候，会跟普通的浏览器有些不一样的地方</p><ol><li><p>UserAgent 会带上 headless 标识<br>解决</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> options = <span class="keyword">new</span> <span class="type">ChromeOptions</span>()</span><br><span class="line">options.addArguments(</span><br><span class="line">   <span class="string">&quot;--headless&quot;</span>,</span><br><span class="line">   <span class="string">s&quot;--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.75 Safari/537.36&quot;</span></span><br><span class="line"> )</span><br></pre></td></tr></table></figure></li><li><p>js 全局对象有值 : window.navigator.webdriver = true<br>解决: 通过 driver.executeCdpCommand 在页面加载时期做一些初始化逻辑</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> driver = <span class="keyword">new</span> <span class="type">ChromeDriver</span>(buildOptions(requestSetting))</span><br><span class="line"><span class="keyword">val</span> map    = <span class="keyword">new</span> util.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">Object</span>]()</span><br><span class="line"> map.put(<span class="string">&quot;source&quot;</span>, <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">     |Object.defineProperty(navigator, &#x27;webdriver&#x27;, &#123;</span></span><br><span class="line"><span class="string">     |      get: () =&gt; false,</span></span><br><span class="line"><span class="string">     |&#125;);</span></span><br><span class="line"><span class="string">     |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin)</span><br><span class="line">driver.executeCdpCommand(<span class="string">&quot;Page.addScriptToEvaluateOnNewDocument&quot;</span>, map)</span><br></pre></td></tr></table></figure></li><li><p>获取 XhrRequest Response<br>解决:</p><ul><li>通过 performanceLog 拿到 requestId</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> performanceLog = driver.manage().logs().get(<span class="type">LogType</span>.<span class="type">PERFORMANCE</span>)</span><br></pre></td></tr></table></figure><ul><li>通过 <code>driver.executeCdpCommand(&quot;Network.getResponseBody&quot;, cdpMap)</code> 来重放 XhrRequest</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cdpMap = <span class="keyword">new</span> util.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">Object</span>]()</span><br><span class="line">cdpMap.put(<span class="string">&quot;requestId&quot;</span>, requestId)</span><br><span class="line">driver.executeCdpCommand(<span class="string">&quot;Network.getResponseBody&quot;</span>, cdpMap).asScala.toMap</span><br></pre></td></tr></table></figure></li></ol><p>PS.</p><ul><li><p>selenium 版本 <code>&quot;org.seleniumhq.selenium&quot; % &quot;selenium-chrome-driver&quot; % &quot;4.0.0-alpha-3&quot;</code> </p></li><li><p><a href="https://github.com/wtog/web-crawler">完整代码</a></p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://intoli.com/blog/making-chrome-headless-undetectable/">MAKING CHROME HEADLESS UNDETECTABLE</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 锁 实现原理总结</title>
      <link href="2019/10/18/java-lock.html"/>
      <url>2019/10/18/java-lock.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>总结一下 java 里面的锁</p><ul><li>Synchronized</li><li>ReentrantLock</li><li>LockSupport</li></ul><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>Java中的每一个对象都可以作为锁</p><ul><li>同步普通方法，锁是当前实例对象。</li><li>同步静态方法，锁是当前类的Class对象。</li><li>同步方法块，锁是Synchonized括号里配置的对象。</li></ul><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li><p>同步方法, JVM 采用 ACC_SYNCHRONIZED 标记符来实现同步<br>方法级的同步是隐式的。同步方法的常量池中会有一个 ACC_SYNCHRONIZED 标志。<br>当某个线程要访问某个方法的时候，会检查是否有 ACC_SYNCHRONIZED，<br>如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。<br>这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。<br>值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。</p></li><li><p>同步代码块, JVM采用 monitorenter、monitorexit 两个指令来实现同步<br>可以把执行 monitorenter 指令理解为加锁，执行 monitorexit 理解为释放锁。<br>每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0<br>当一个线程获得锁（执行 monitorenter ）后，该计数器自增变为 1，当同一个线程再次获得该对象的锁的时候，计数器再次自增。<br>当同一个线程释放锁（执行 monitorexit 指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。</p></li><li><p>锁的信息维护在Java头对象里面, Java 对象头包括</p><ul><li>Mark Word</li><li>指向类的指针</li><li>数组长度（只有数组对象才有）</li></ul><p>这里只重点说一下 Mark Word, Mark Word 记录了对象和锁有关的信息，当这个对象被 synchronized 关键字当成同步锁时，围绕这个锁的一系列操作都和 Mark Word 有关</p><img data-original="java-lock/markword.png" class="lazy" alt="java-markword" src="/images/squares.svg"></li></ul><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>每一个线程在准备获取共享资源时： </p><ol><li>检查 MarkWord 里面是不是放的自己的 ThreadId, 如果是, 表示当前线程是处于 “偏向锁” </li><li>如果 MarkWord 不是自己的 ThreadId,锁升级，这时候，用CAS来执行切换，新的线程根据 MarkWord 里面现有的 ThreadId，通知之前线程暂停，之前线程将 Markword 的内容置为空</li><li>两个线程都把对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作把共享对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord</li><li>第三步中成功执行CAS的获得资源，失败的则进入自旋 </li><li>自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败 </li><li>进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己</li></ol><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  lock.lock();  <span class="comment">// block until condition holds</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ... method body</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li>new ReentrantLock() 初始化<ul><li>公平锁</li><li>非公平锁</li></ul></li></ul><p>基于 AQS <code>AbstractOwnableSynchronizer</code> </p><ul><li><p>lock.lock() 仅包含非公平锁的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果之前无线程获取锁，则标志当前线程获取独占锁, 否则，进入 acquire(1)</li><li>tryAquire 的逻辑为 获取 state 值（父类中 volatile 修饰的整型属性）<ul><li>如果 state = 0，则标志当前线程获取独占锁</li><li>如果 state != 0, 并且获得独占锁的线程是当前线程，则 state 值+1（这也是可重入的原因）<br>以上条件都返回 true，拿到了锁，可继续往下执行</li></ul></li><li>如果没拿到独占锁，则将当前线程包装到 Node 里面，acquireQueued 加入等待队列（Node组成的链表）<br>并且不断的用 Node 链表的尾节点 tryAcquire 尝试获取锁</li></ol></li><li><p>lock.unlock()  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unlock 释放锁 tryRelease 对 state 值（父类中 volatile 修饰的整型属性）进行自减操作（重入机制会导致 state 值 &gt; 1）<br>直到 state = 0 锁完全释放  </p></li></ul><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>通过 Unsafe 类里的函数实现的锁</p><h3 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  所有线程共享一个 permit</p><ul><li>park 拿到 permit，获得锁继续执行，其他线程只能阻塞, 因为不支持重入，一个线程多次 park 会一直阻塞下去</li><li>unpark 释放 permit，释放锁，可唤醒其他线程继续执行</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala Jackson 使用经验总结</title>
      <link href="2019/10/10/scala-jackson.html"/>
      <url>2019/10/10/scala-jackson.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>主要记录 scala 使用 jackson 中的几个问题</p><ul><li>long 型数据转换为 ZonedDateTime </li><li>对 field 做自定义反序列化</li></ul><p>以下面对 json 为例</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;time&quot;</span>: <span class="number">1570712743943</span>, <span class="comment">//time 为 Long ，反序列化需要映射成 ZonedDateTime </span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="number">1</span> <span class="comment">// id 为 Integer，反序列化成 String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scala 代码示例</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.<span class="type">ZonedDateTime</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.<span class="type">JsonInclude</span>.<span class="type">Include</span></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.<span class="type">JsonParser</span></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.annotation.<span class="type">JsonDeserialize</span></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.deser.std.<span class="type">StdDeserializer</span></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.&#123;<span class="type">DeserializationContext</span>, <span class="type">DeserializationFeature</span>, <span class="type">ObjectMapper</span>&#125;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.datatype.jsr310.<span class="type">JavaTimeModule</span></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.module.scala.<span class="type">DefaultScalaModule</span></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.module.scala.experimental.<span class="type">ScalaObjectMapper</span></span><br><span class="line"><span class="keyword">import</span> org.scalatest.<span class="type">FunSuite</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestJackson</span> <span class="keyword">extends</span> <span class="title">FunSuite</span> </span>&#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> mapper = &#123;</span><br><span class="line">      <span class="keyword">val</span> mapper = <span class="keyword">new</span> <span class="type">ObjectMapper</span>() <span class="keyword">with</span> <span class="type">ScalaObjectMapper</span></span><br><span class="line">      mapper.registerModule(<span class="keyword">new</span> <span class="type">JavaTimeModule</span>())</span><br><span class="line">      mapper.setSerializationInclusion(<span class="type">Include</span>.<span class="type">NON_NULL</span>)</span><br><span class="line">      mapper.setSerializationInclusion(<span class="type">Include</span>.<span class="type">NON_ABSENT</span>)</span><br><span class="line">      mapper.configure(<span class="type">DeserializationFeature</span>.<span class="type">FAIL_ON_UNKNOWN_PROPERTIES</span>, <span class="literal">false</span>)</span><br><span class="line">      mapper.registerModule(<span class="type">DefaultScalaModule</span>)</span><br><span class="line">      mapper</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  test(<span class="string">&quot;jackson&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> json =</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |&#123;</span></span><br><span class="line"><span class="string">        | &quot;</span><span class="string">time&quot;: 1570712743943,</span></span><br><span class="line"><span class="string">        | &quot;</span><span class="string">id&quot;: 1</span></span><br><span class="line"><span class="string">        |&#125;</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> t = mapper.readValue(json, classOf[<span class="type">Test</span>])</span><br><span class="line"></span><br><span class="line">    println(<span class="string">s&quot;time type: <span class="subst">$&#123;t.time.getClass.getSimpleName&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">s&quot;id   type: <span class="subst">$&#123;t.id.getClass.getSimpleName&#125;</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdDeserializer</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">StdDeserializer</span>[<span class="type">String</span>](<span class="params">classOf[<span class="type">String</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span></span>(p: <span class="type">JsonParser</span>, ctxt: <span class="type">DeserializationContext</span>): <span class="type">String</span> = &#123;</span><br><span class="line">    p.getValueAsString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params">time: <span class="type">ZonedDateTime</span>, @<span class="type">JsonDeserialize</span>(using = classOf[<span class="type">IdDeserializer</span>]</span>) <span class="title">id</span></span>: <span class="type">String</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time type: ZonedDateTime</span><br><span class="line">id   type: String</span><br></pre></td></tr></table></figure><p>回到问题</p><ul><li><p>long 型数据转换为 ZonedDateTime</p><ul><li>通过 new JavaTimeModule() 来实现 java8 中特有的 ZonedDateTime 的映射</li></ul></li><li><p>对 field 实现自定义反序列化 </p><ul><li>通过 <code>@JsonDeserialize(using = classOf[IdDeserializer])</code> 指定需要自定义反序列化的 field</li><li>通过 <code>class IdDeserializer().deserialize</code> 实现反序列化的逻辑</li></ul></li></ul><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>sbt dependencies</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val jackson &#x3D; Seq(</span><br><span class="line">  &quot;com.fasterxml.jackson.module&quot; %% &quot;jackson-module-scala&quot; % &quot;2.9.9&quot;,</span><br><span class="line">  &quot;com.fasterxml.jackson.datatype&quot; % &quot;jackson-datatype-jdk8&quot; % &quot;2.9.9&quot;,</span><br><span class="line">  &quot;com.fasterxml.jackson.datatype&quot; % &quot;jackson-datatype-jsr310&quot; % &quot;2.9.9&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
            <tag> jackson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala 设计模式 装饰者</title>
      <link href="2019/09/25/scala-decorator-pattern.html"/>
      <url>2019/09/25/scala-decorator-pattern.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为。装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能</p><h2 id="利用-implicit-class-装饰"><a href="#利用-implicit-class-装饰" class="headerlink" title="利用 implicit class 装饰"></a>利用 implicit class 装饰</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">m</span></span>() = println(<span class="string">&quot;origin&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWrapper</span>(<span class="params">t: <span class="type">Test</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span></span>() = println(<span class="string">&quot;wrapper&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> t = <span class="type">Test</span>()</span><br><span class="line"></span><br><span class="line">t.m()</span><br><span class="line">t.wrapper()<span class="comment">//给 Test 对象,增加额外的行为</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//print</span></span><br><span class="line"></span><br><span class="line">origin</span><br><span class="line">wrapper</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> design-pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala lazy 实现原理</title>
      <link href="2019/09/25/scala-lazy.html"/>
      <url>2019/09/25/scala-lazy.html</url>
      
        <content type="html"><![CDATA[<h2 id="Lazy-有啥用"><a href="#Lazy-有啥用" class="headerlink" title="Lazy 有啥用"></a>Lazy 有啥用</h2><p>延迟计算：被 lazy 修饰的变量只有在第一次调用的时候，才会被初始化</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> queue: <span class="type">LinkedBlockingQueue</span>[<span class="type">RequestSetting</span>] = <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>[<span class="type">RequestSetting</span>]()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pushWhenNoDuplicate</span></span>(request: <span class="type">RequestSetting</span>): <span class="type">Unit</span> = <span class="keyword">this</span>.queue.add(request)</span><br></pre></td></tr></table></figure><p>当第一次调用 pushWhenNoDuplicate 的时候，queue 才会被初始化</p><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>scala 最终是要被编译成 class 字节码，才能运行在 jvm 上的</p><p>所以我们通过 jd-gui 来看看 lazy 在 class 文件中长什么样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> LinkedBlockingQueue&lt;RequestSetting&gt; queue;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> bitmap$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TargetRequestTaskQueue</span><span class="params">(DuplicateRemovedStrategy duplicateRemovedStrategy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(duplicateRemovedStrategy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> LinkedBlockingQueue&lt;RequestSetting&gt; queue$lzycompute()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.bitmap$<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedBlockingQueue();<span class="keyword">this</span>.bitmap$<span class="number">0</span> = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> LinkedBlockingQueue&lt;RequestSetting&gt; <span class="title">queue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !<span class="keyword">this</span>.bitmap$<span class="number">0</span> ? queue$lzycompute() : <span class="keyword">this</span>.queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码看出，lazy 是通过 volatile + synchronized 的组合来实现延迟加载的 </p>]]></content>
      
      
      <categories>
          
          <category> scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 与 Spark 架构对比</title>
      <link href="2019/09/10/flink-vs-spark.html"/>
      <url>2019/09/10/flink-vs-spark.html</url>
      
        <content type="html"><![CDATA[<h2 id="架构对比"><a href="#架构对比" class="headerlink" title="架构对比"></a>架构对比</h2><h3 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h3><p>  当 Flink 集群启动后，首先会启动一个 JobManger 和一个或多个的 TaskManager。<br>  由 Client 提交任务给 JobManager，JobManager 再调度任务到各个 TaskManager 去执行。<br>  然后 TaskManager 将心跳和统计信息汇报给 JobManager。TaskManager 之间以流的形式进行数据的传输。<br>  上述三者均为独立的 JVM 进程。</p>  <img data-original="flink-vs-spark/flink-architecture.png" class="lazy" alt="flink-archicture" src="/images/squares.svg"><ul><li><p>Client 为提交 Job 的客户端，可以是运行在任何机器上（与 JobManager 环境连通即可）。提交 Job 后，Client 可以结束进程（Streaming的任务），也可以不结束并等待结果返回。</p></li><li><p>JobManager 主要负责调度 Job 并协调 Task 做 checkpoint，职责上很像 Storm 的 Nimbus。从 Client 处接收到 Job 和 JAR 包等资源后，会生成优化后的执行计划，并以 Task 的单元调度到各个 TaskManager 去执行。</p></li><li><p>TaskManager 在启动的时候就设置好了槽位数（Slot），每个 slot 能启动一个 Task，Task 为线程。从 JobManager 处接收需要部署的 Task，部署启动后，与自己的上游建立 Netty 连接，接收数据并处理。</p><p>可以看到 Flink 的任务调度是多线程模型，并且不同 Job/Task 混合在一个 TaskManager 进程中。虽然这种方式可以有效提高 CPU 利用率，但是不仅缺乏资源隔离机制，同时也不方便调试。</p></li></ul><h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><p>  Spark 应用程序在集群上作为独立的进程集运行，由主程序（称为驱动程序）中的sparkContext对象协调。<br>  具体来说，要在集群上运行，sparkContext可以连接到几种类型的集群管理器（spark自己的独立集群管理器、mesos或yarn）,<br>  它们在应用程序之间分配资源一旦连接, spark将获取集群中节点上的执行器，这些节点是运行计算和存储应用程序数据的进程。<br>  接下来，它将应用程序代码（由传递给sparkcontext的jar或python文件定义）发送给执行器。最后，sparkContext将任务发送给执行器以运行。</p>  <img data-original="flink-vs-spark/spark-architecture.png" class="lazy" alt="spark-architecture" src="/images/squares.svg"><ul><li>每个应用都会有自己的处理器进程，处理器上会利用多线程执行任务。这样做到了应用级的隔离, 定时任务或者处理器任务都可以跑在不同的Jvm上。这样做的弊端是不能很好的进行多应用(SparkContext)之间的   数据共享，除非应用之间是共享一个数据存储</li><li>Spark 支持多种底层集群管理器, 因为他可以申请处理器进程, 并且彼此间可以互相通信，它很容易的就可以跑在类似 Mesos/YARN 的集群管理服务器上  </li><li>Driver Program 会一直管理 SprintContext 的请求，Driver Program 会执行集群上的任务，Driver Program 和工作节点一定是要网络互通的，最好和 work node 在一个局域网之内运行,如果需要远程向群集发送请求，最好让 Driver Program 通过 RPC 提交请求操作</li></ul><h3 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h3><p>  YARN总体上是 Master/Slave 结构，主要由 ResourceManager、NodeManager、 ApplicationMaster 和 Container 等几个组件构成。</p>  <img data-original="flink-vs-spark/yarn-architecture.png" class="lazy" alt="yarn-architecture" src="/images/squares.svg"> <ul><li><p>ResourceManager(RM)<br>负责对各NM上的资源进行统一管理和调度。将AM分配空闲的Container运行并监控其运行状态。对AM申请的资源请求分配相应的空闲Container。<br>主要由两个组件构成：调度器和应用程序管理器</p><ul><li><p>调度器(Scheduler)<br>调度器根据容量、队列等限制条件（如每个队列分配一定的资源，最多执行一定数量的作业等）将系统中的资源分配给各个正在运行的应用程序。调度器仅根据各个应用程序的资源需求进行资源分配，而资源分配单位是Container，从而限定每个任务使用的资源量。Shceduler不负责监控或者跟踪应用程序的状态，也不负责任务因为各种原因而需要的重启（由ApplicationMaster负责）。总之，调度器根据应用程序的资源要求，以及集群机器的资源情况，为应用程序分配封装在Container中的资源。调度器是可插拔的，例如CapacityScheduler、FairScheduler。</p></li><li><p>应用程序管理器(Applications Manager)<br>应用程序管理器负责管理整个系统中所有应用程序，包括应用程序提交、与调度器协商资源以启动AM、监控AM运行状态并在失败时重新启动等，跟踪分给的Container的进度、状态也是其职责。</p></li></ul></li><li><p>NodeManager (NM)<br>NM是每个节点上的资源和任务管理器。它会定时地向RM汇报本节点上的资源使用情况和各个Container的运行状态；同时会接收并处理来自AM的Container 启动/停止等请求。</p></li><li><p>ApplicationMaster (AM)<br>用户提交的应用程序均包含一个AM，负责应用的监控，跟踪应用执行状态，重启失败任务等。ApplicationMaster是应用框架，它负责向ResourceManager协调资源，并且与NodeManager协同工作完成Task的执行和监控。MapReduce就是原生支持的一种框架，可以在YARN上运行Mapreduce作业。有很多分布式应用都开发了对应的应用程序框架，用于在YARN上运行任务，例如Spark，Storm等。如果需要，我们也可以自己写一个符合规范的YARN application。</p></li><li><p>Container<br>Container是YARN中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等，当AM向RM申请资源时，RM为AM返回的资源便是用Container 表示的。 YARN会为每个任务分配一个Container且该任务只能使用该Container中描述的资源</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[<a href="http://wuchong.me/blog/2016/05/03/flink-internals-overview/]">http://wuchong.me/blog/2016/05/03/flink-internals-overview/]</a></li><li>[<a href="https://spark.apache.org/docs/latest/cluster-overview.html]">https://spark.apache.org/docs/latest/cluster-overview.html]</a></li><li>[<a href="https://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/YARN.html]">https://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/YARN.html]</a></li><li><a href="https://union-click.jd.com/jdc?e=&p=AyIGZRtYFAcXBFIZWR0yEgRRElMVChs3EUQDS10iXhBeGlcJDBkNXg9JHU4YDk5ER1xOGRNLGEEcVV8BXURFUFdfC0RVU1JRUy1OVxUBFg5dG1McMnpRHEwdHQtrZShfA09eT3wLBVteflQLWStaJQITBlQYWBYEFA5lK1sSMkBpja3tzaejG4Gx1MCKhTdUK1sRBRsDXRhYEAQWDlcrXBULIkEQRB9IXyI3ZRhrJTISN1YrGXsBEFRdTAlFBRcCU0xeHAQRDgdMDhxQElAATwgTAhVUBytZFAMWDg==">深入理解Flink:实时大数据处理实践</a></li><li><a href="https://union-click.jd.com/jdc?e=&p=AyIGZRtYFAcXBFIZWR0yEgRXGlgRAxM3EUQDS10iXhBeGlcJDBkNXg9JHU4YDk5ER1xOGRNLGEEcVV8BXURFUFdfC0RVU1JRUy1OVxUBEAZWH1oUMnRYLEICTVxpZCt9HUVZYGcueghiY0QLWStaJQITBlQYWBYEFA5lK1sSMkBpja3tzaejG4Gx1MCKhTdUK1sRBRsDXRhfEwcTDlMrXBULIkEQRB9IXyI3ZRhrJTISN1YrGXsKEQEAGQgSAkIHUkxeRlUTDlATWhYLRwFTH1JGUBMAVCtZFAMWDg==">Spark内核设计的艺术：架构设计与实现</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> big-data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> big-data </tag>
            
            <tag> flink </tag>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala 设计模式 责任链</title>
      <link href="2019/09/04/scala-chain-of-responsibility-pattern.html"/>
      <url>2019/09/04/scala-chain-of-responsibility-pattern.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>责任链模式（Chain of Responsibility）是行为型设计模式之一<br>其将链中每一个节点看作是一个对象，每个节点处理的请求均不同，且内部自动维护一个下一节点对象</p><ul><li>纯：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。</li><li>不纯：允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收。</li></ul><h2 id="利用-trait-实现纯责任链"><a href="#利用-trait-实现纯责任链" class="headerlink" title="利用 trait 实现纯责任链"></a>利用 trait 实现纯责任链</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">L</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">p</span></span>(x: <span class="type">Int</span>): <span class="type">Int</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">&quot;aa&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">L1</span> <span class="keyword">extends</span> <span class="title">L</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">p</span></span>(x: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;enter l1&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">      x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.p(x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">L2</span> <span class="keyword">extends</span> <span class="title">L</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">p</span></span>(x: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;enter l2&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span>) &#123;</span><br><span class="line">      x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.p(x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">L1</span> <span class="keyword">with</span> <span class="title">L2</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">C</span>.<span class="title">p</span>(<span class="params">1</span>)</span></span><br><span class="line"><span class="class"><span class="title">println</span>(<span class="params">&quot;--------&quot;</span>)</span></span><br><span class="line"><span class="class"><span class="title">C</span>.<span class="title">p</span>(<span class="params">2</span>)</span></span><br><span class="line"><span class="class"><span class="title">println</span>(<span class="params">&quot;--------&quot;</span>)</span></span><br><span class="line"><span class="class"><span class="title">C</span>.<span class="title">p</span>(<span class="params">3</span>)</span></span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">enter l2</span><br><span class="line">enter l1</span><br><span class="line">--------</span><br><span class="line">enter l2</span><br><span class="line">--------</span><br><span class="line">enter l2</span><br><span class="line">enter l1</span><br><span class="line">java.lang.IllegalStateException: aa</span><br><span class="line">  at L.p(&lt;pastie&gt;:12)</span><br><span class="line">  at L.p$(&lt;pastie&gt;:12)</span><br><span class="line">  at C$.$line6$$read$L1$$super$p(&lt;pastie&gt;:37)</span><br><span class="line">  at L1.p(&lt;pastie&gt;:21)</span><br><span class="line">  at L1.p$(&lt;pastie&gt;:16)</span><br><span class="line">  at C$.$line6$$read$L2$$super$p(&lt;pastie&gt;:37)</span><br><span class="line">  at L2.p(&lt;pastie&gt;:32)</span><br><span class="line">  at L2.p$(&lt;pastie&gt;:27)</span><br><span class="line">  at C$.p(&lt;pastie&gt;:37)</span><br><span class="line">  ... 37 elided</span><br></pre></td></tr></table></figure><p>由输出信息可以看出执行顺序是 L2 -&gt; L1 </p><p>当条件 x = 1 时，先走 L2 不满足条件，去 L1 处理<br>当条件 x = 2 时，先走 L2 满足条件处理完结束<br>当条件 x = 3 时，先走 L2, 再到 L1, 都不满足, 在 trait 中 处理 抛出异常</p><h2 id="利用-Scala-偏函数-实现责任链"><a href="#利用-Scala-偏函数-实现责任链" class="headerlink" title="利用 Scala 偏函数 实现责任链"></a>利用 Scala 偏函数 实现责任链</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b1: <span class="type">PartialFunction</span>[<span class="type">String</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">  <span class="keyword">case</span> o =&gt; <span class="string">s&quot;<span class="subst">$o</span>-b1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> b2: <span class="type">PartialFunction</span>[<span class="type">String</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">  <span class="keyword">case</span> o =&gt; <span class="string">s&quot;<span class="subst">$o</span>-b2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> b3: <span class="type">PartialFunction</span>[<span class="type">String</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">  <span class="keyword">case</span> o =&gt; <span class="string">s&quot;<span class="subst">$o</span>-b3&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> andthen: <span class="type">String</span> =&gt; <span class="type">String</span> = b1 andThen b2 andThen b3</span><br><span class="line"><span class="keyword">val</span> orelse: <span class="type">String</span> =&gt; <span class="type">String</span> = b1 orElse b2 orElse b3</span><br><span class="line"></span><br><span class="line">println(andthen(<span class="string">&quot;1&quot;</span>)) </span><br><span class="line">println(orelse(<span class="string">&quot;1&quot;</span>))</span><br></pre></td></tr></table></figure><p>由输出信息可以看出 andthen 是不纯责任链，orelse 是纯责任链</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">andthen-b1-b2-b3</span><br><span class="line">orelse-b1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> design-pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Disruptor 高性能队列</title>
      <link href="2019/08/13/high-performance-queue-disruptor.html"/>
      <url>2019/08/13/high-performance-queue-disruptor.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>记录一下 disruptor 的学习笔记</p><h2 id="Disruptor-例子"><a href="#Disruptor-例子" class="headerlink" title="Disruptor 例子"></a>Disruptor 例子</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.<span class="type">ThreadFactory</span></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.dsl.&#123;<span class="type">Disruptor</span>, <span class="type">ProducerType</span>&#125;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.&#123;<span class="type">BlockingWaitStrategy</span>,<span class="type">EventFactory</span>,<span class="type">EventHandler</span>,<span class="type">EventTranslatorOneArg</span>,<span class="type">WaitStrategy</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DisruptorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> disruptor = &#123;</span><br><span class="line">    <span class="keyword">val</span> factory = <span class="keyword">new</span> <span class="type">EventFactory</span>[<span class="type">Event</span>] &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">newInstance</span></span>(): <span class="type">Event</span> = <span class="type">Event</span>(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> threadFactory = <span class="keyword">new</span> <span class="type">ThreadFactory</span>()&#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">newThread</span></span>(r: <span class="type">Runnable</span>): <span class="type">Thread</span> = <span class="keyword">new</span> <span class="type">Thread</span>(r)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> disruptor = <span class="keyword">new</span> <span class="type">Disruptor</span>[<span class="type">Event</span>](factory, <span class="number">4</span>, threadFactory, <span class="type">ProducerType</span>.<span class="type">SINGLE</span>, <span class="keyword">new</span> <span class="type">BlockingWaitStrategy</span>())</span><br><span class="line"></span><br><span class="line">    disruptor.handleEventsWith(<span class="type">TestHandler</span>).`then`(<span class="type">ThenHandler</span>)</span><br><span class="line">    </span><br><span class="line">    disruptor</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">val</span> translator = <span class="keyword">new</span> <span class="type">EventTranslatorOneArg</span>[<span class="type">Event</span>, <span class="type">Int</span>]() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">translateTo</span></span>(event: <span class="type">Event</span>, sequence: <span class="type">Long</span>, arg: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      event.id = arg</span><br><span class="line">      println(<span class="string">s&quot;translator: <span class="subst">$&#123;event&#125;</span>, sequence: <span class="subst">$&#123;sequence&#125;</span>, arg: <span class="subst">$&#123;arg&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    disruptor.start()</span><br><span class="line">    (<span class="number">0</span> until <span class="number">100</span>).foreach &#123; i =&gt;</span><br><span class="line">      disruptor.publishEvent(translator, i)</span><br><span class="line">    &#125;</span><br><span class="line">    disruptor.shutdown()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span>(<span class="params">var id: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = <span class="string">s&quot;event: <span class="subst">$&#123;id&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestHandler</span> <span class="keyword">extends</span> <span class="title">EventHandler</span>[<span class="type">Event</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onEvent</span></span>(event: <span class="type">Event</span>, sequence: <span class="type">Long</span>, endOfBatch: <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s&quot;<span class="subst">$&#123;this.getClass.getSimpleName&#125;</span> <span class="subst">$&#123;System.nanoTime()&#125;</span> <span class="subst">$&#123;event&#125;</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ThenHandler</span> <span class="keyword">extends</span> <span class="title">EventHandler</span>[<span class="type">Event</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onEvent</span></span>(event: <span class="type">Event</span>, sequence: <span class="type">Long</span>, endOfBatch: <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s&quot;<span class="subst">$&#123;this.getClass.getSimpleName&#125;</span> <span class="subst">$&#123;System.nanoTime()&#125;</span> <span class="subst">$&#123;event&#125;</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><h3 id="disrutpor-初始化"><a href="#disrutpor-初始化" class="headerlink" title="disrutpor 初始化"></a>disrutpor 初始化</h3><p>先看 Disruptor 构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Disruptor</span><span class="params">(<span class="keyword">final</span> EventFactory&lt;T&gt; eventFactory, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> <span class="keyword">int</span> ringBufferSize, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> ThreadFactory threadFactory, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> ProducerType producerType,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> WaitStrategy waitStrategy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(RingBuffer.create(producerType, eventFactory, ringBufferSize, waitStrategy), </span><br><span class="line">        <span class="keyword">new</span> BasicExecutor(threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在看 RingBuffer.create, 最终通过 fill 方法 将 eventFactory.newInstance() 作为默认值，塞到 ringBuffer 里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">RingBuffer&lt;E&gt; <span class="title">create</span><span class="params">(ProducerType producerType, </span></span></span><br><span class="line"><span class="function"><span class="params">  EventFactory&lt;E&gt; factory, <span class="keyword">int</span> bufferSize, WaitStrategy waitStrategy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (producerType) &#123;</span><br><span class="line">        <span class="keyword">case</span> SINGLE:</span><br><span class="line">            <span class="keyword">return</span> createSingleProducer(factory, bufferSize, waitStrategy);</span><br><span class="line">        <span class="keyword">case</span> MULTI:</span><br><span class="line">            <span class="keyword">return</span> createMultiProducer(factory, bufferSize, waitStrategy);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(producerType.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">RingBuffer&lt;E&gt; <span class="title">createSingleProducer</span><span class="params">(EventFactory&lt;E&gt; factory, <span class="keyword">int</span> bufferSize, </span></span></span><br><span class="line"><span class="function"><span class="params">    WaitStrategy waitStrategy)</span> </span>&#123;</span><br><span class="line">    SingleProducerSequencer sequencer = <span class="keyword">new</span> SingleProducerSequencer(bufferSize, waitStrategy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RingBuffer&lt;E&gt;(factory, sequencer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RingBufferFields(EventFactory&lt;E&gt; eventFactory, Sequencer sequencer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.sequencer = sequencer;</span><br><span class="line">    <span class="keyword">this</span>.bufferSize = sequencer.getBufferSize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferSize &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;bufferSize must not be less than 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Integer.bitCount(bufferSize) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;bufferSize must be a power of 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.indexMask = bufferSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.entries = <span class="keyword">new</span> Object[sequencer.getBufferSize() + <span class="number">2</span> * BUFFER_PAD];</span><br><span class="line">    fill(eventFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(EventFactory&lt;E&gt; eventFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bufferSize; i++) &#123;</span><br><span class="line">        entries[BUFFER_PAD + i] = eventFactory.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费事件消息"><a href="#消费事件消息" class="headerlink" title="消费事件消息"></a>消费事件消息</h3><p>首先看 disruptor.start(): 消费事件消息入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConsumerRepository&lt;T&gt; consumerRepository = <span class="keyword">new</span> ConsumerRepository&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RingBuffer&lt;T&gt; <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkOnlyStartedOnce();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> ConsumerInfo consumerInfo : consumerRepository) &#123;</span><br><span class="line">        consumerInfo.start(executor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ringBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>consumerRepository 类型由 disruptor.handleEventsWith(TestHandler) 初始化, 并构造事件消息处理链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> EventHandlerGroup&lt;T&gt; <span class="title">handleEventsWith</span><span class="params">(<span class="keyword">final</span> EventHandler&lt;? <span class="keyword">super</span> T&gt;... handlers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createEventProcessors(<span class="keyword">new</span> Sequence[<span class="number">0</span>], handlers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EventHandlerGroup&lt;T&gt; <span class="title">createEventProcessors</span><span class="params">(<span class="keyword">final</span> Sequence[] barrierSequences, <span class="keyword">final</span> EventHandler&lt;? <span class="keyword">super</span> T&gt;[] eventHandlers)</span> </span>&#123;</span><br><span class="line">    checkNotStarted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Sequence[] processorSequences = <span class="keyword">new</span> Sequence[eventHandlers.length];</span><br><span class="line">    <span class="keyword">final</span> SequenceBarrier barrier = ringBuffer.newBarrier(barrierSequences);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, eventHandlersLength = eventHandlers.length; i &lt; eventHandlersLength; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> EventHandler&lt;? <span class="keyword">super</span> T&gt; eventHandler = eventHandlers[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> BatchEventProcessor&lt;T&gt; batchEventProcessor = <span class="keyword">new</span> BatchEventProcessor&lt;&gt;(ringBuffer, barrier, eventHandler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exceptionHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            batchEventProcessor.setExceptionHandler(exceptionHandler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        consumerRepository.add(batchEventProcessor, eventHandler, barrier);</span><br><span class="line">        processorSequences[i] = batchEventProcessor.getSequence();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateGatingSequencesForNextInChain(barrierSequences, processorSequences);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EventHandlerGroup&lt;&gt;(<span class="keyword">this</span>, consumerRepository, processorSequences);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回头看 disruptor.start() 中的 consumerInfo.start(executor)<br>executor = new BasicExecutor(threadFactory)，BasicExecutor 在每次 execute 任务时， 每个 consumer 被分配一个 new thread </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Disruptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> EventFactory&lt;T&gt; eventFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">int</span> ringBufferSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ProducerType producerType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> WaitStrategy waitStrategy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(</span><br><span class="line">        RingBuffer.create(producerType, eventFactory, ringBufferSize, waitStrategy),</span><br><span class="line">        <span class="keyword">new</span> BasicExecutor(threadFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Disruptor</span><span class="params">(<span class="keyword">final</span> RingBuffer&lt;T&gt; ringBuffer, <span class="keyword">final</span> Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ringBuffer = ringBuffer;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> java.util.concurrent.Executor executor)</span></span>&#123;</span><br><span class="line">    <span class="comment">//EventProcessor extends Runnable</span></span><br><span class="line">    <span class="comment">//executor = BasicExecutor </span></span><br><span class="line">    executor.execute(eventprocessor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchEventProcessor</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">EventProcessor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (running.compareAndSet(IDLE, RUNNING)) &#123;</span><br><span class="line">          sequenceBarrier.clearAlert();</span><br><span class="line"></span><br><span class="line">          notifyStart();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (running.get() == RUNNING) &#123;</span><br><span class="line">                  processEvents();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              notifyShutdown();</span><br><span class="line">              running.set(IDLE);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (running.get() == RUNNING) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Thread is already running&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              earlyExit();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T event = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> nextSequence = sequence.get() + <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> availableSequence = sequenceBarrier.waitFor(nextSequence);</span><br><span class="line">            <span class="keyword">if</span> (batchStartAware != <span class="keyword">null</span>) &#123;</span><br><span class="line">                batchStartAware.onBatchStart(availableSequence - nextSequence + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (nextSequence &lt;= availableSequence) &#123;</span><br><span class="line">                event = dataProvider.get(nextSequence);</span><br><span class="line">                eventHandler.onEvent(event, nextSequence, nextSequence == availableSequence);</span><br><span class="line">                nextSequence++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sequence.set(availableSequence);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> TimeoutException e) &#123;</span><br><span class="line">            notifyTimeout(sequence.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> AlertException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (running.get() != RUNNING) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable ex) &#123;</span><br><span class="line">            exceptionHandler.handleEventException(ex, nextSequence, event);</span><br><span class="line">            sequence.set(nextSequence);</span><br><span class="line">            nextSequence++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>executor.execute 也就是 BasicExecutor.execute(eventHandler) 会异步的执行 eventHandler, 也就是调用 BatchEventProcessor.run 方法</p><p>问题来了，既然是异步执行，多个 eventHandler 是怎么按照顺序去处理事件消息的？</p><p>我们看 processEvents 方法执行逻辑</p><ol><li><p>先获取 BatchEventProcessor.sequence 并 +1</p></li><li><p>通过 sequenceBarrier.waitFor 也就是 WaitStrategy.waitFor 获取到可用的 availableSequence</p></li><li><p>先看下 BlockingWaitStrategy.waitFor 的实现</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">waitFor</span><span class="params">(<span class="keyword">long</span> sequence, Sequence cursorSequence, Sequence dependentSequence, </span></span></span><br><span class="line"><span class="function"><span class="params">    SequenceBarrier barrier)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> AlertException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> availableSequence;</span><br><span class="line">    <span class="keyword">if</span> (cursorSequence.get() &lt; sequence) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (cursorSequence.get() &lt; sequence) &#123;</span><br><span class="line">                barrier.checkAlert();</span><br><span class="line">                processorNotifyCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((availableSequence = dependentSequence.get()) &lt; sequence) &#123;</span><br><span class="line">        barrier.checkAlert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> availableSequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 cursorSequence(ringbuffer 的索引) &lt; sequence(batchEventProcessor 的索引) 则batchEventProcessor挂起等待<br>否则 就用 <strong>dependentSequence</strong> 作为 availableSequence 返回<br>然后 batchEventProcessor 会将 availableSequence 索引之前的数据一次性处理完，并更新自身的 sequence 索引值</p></li><li><p>dependentSequence 由 ProcessingSequenceBarrier 构造方法初始化</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessingSequenceBarrier</span> <span class="keyword">implements</span> <span class="title">SequenceBarrier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WaitStrategy waitStrategy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequence dependentSequence;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> alerted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequence cursorSequence;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequencer sequencer;</span><br><span class="line"></span><br><span class="line">    ProcessingSequenceBarrier(<span class="keyword">final</span> Sequencer sequencer, <span class="keyword">final</span> WaitStrategy waitStrategy,</span><br><span class="line">        <span class="keyword">final</span> Sequence cursorSequence, <span class="keyword">final</span> Sequence[] dependentSequences) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sequencer = sequencer;</span><br><span class="line">        <span class="keyword">this</span>.waitStrategy = waitStrategy;</span><br><span class="line">        <span class="keyword">this</span>.cursorSequence = cursorSequence;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == dependentSequences.length) &#123;</span><br><span class="line">            dependentSequence = cursorSequence;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dependentSequence = <span class="keyword">new</span> FixedSequenceGroup(dependentSequences);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在 Disruptor.createEventProcessors 中的, 进行了初始化 ProcessingSequenceBarrier<br> <code>final SequenceBarrier barrier = ringBuffer.newBarrier(barrierSequences)</code><br> createEventProcessors 仅会被 <strong>Disruptor.handleEventsWith</strong> 和 <strong>EventHandlerGroup.handleEventsWith</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Disruptor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> EventHandlerGroup&lt;T&gt; <span class="title">handleEventsWith</span><span class="params">(<span class="keyword">final</span> EventHandler&lt;? <span class="keyword">super</span> T&gt;... handlers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createEventProcessors(<span class="keyword">new</span> Sequence[<span class="number">0</span>], handlers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">EventHandlerGroup&lt;T&gt; <span class="title">createEventProcessors</span><span class="params">(<span class="keyword">final</span> Sequence[] barrierSequences,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> EventHandler&lt;? <span class="keyword">super</span> T&gt;[] eventHandlers)</span> </span>&#123;</span><br><span class="line">        checkNotStarted();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Sequence[] processorSequences = <span class="keyword">new</span> Sequence[eventHandlers.length];</span><br><span class="line">        <span class="keyword">final</span> SequenceBarrier barrier = ringBuffer.newBarrier(barrierSequences);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, eventHandlersLength = eventHandlers.length; i &lt; eventHandlersLength; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> EventHandler&lt;? <span class="keyword">super</span> T&gt; eventHandler = eventHandlers[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> BatchEventProcessor&lt;T&gt; batchEventProcessor = </span><br><span class="line">                <span class="keyword">new</span> BatchEventProcessor&lt;&gt;(ringBuffer, barrier, eventHandler);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (exceptionHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                batchEventProcessor.setExceptionHandler(exceptionHandler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            consumerRepository.add(batchEventProcessor, eventHandler, barrier);</span><br><span class="line">            processorSequences[i] = batchEventProcessor.getSequence();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        updateGatingSequencesForNextInChain(barrierSequences, processorSequences);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EventHandlerGroup&lt;&gt;(<span class="keyword">this</span>, consumerRepository, processorSequences);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventHandlerGroup</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Disruptor&lt;T&gt; disruptor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConsumerRepository&lt;T&gt; consumerRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequence[] sequences;</span><br><span class="line"></span><br><span class="line">    EventHandlerGroup(<span class="keyword">final</span> Disruptor&lt;T&gt; disruptor, <span class="keyword">final</span> ConsumerRepository&lt;T&gt; consumerRepository,</span><br><span class="line">        <span class="keyword">final</span> Sequence[] sequences) &#123;</span><br><span class="line">        <span class="keyword">this</span>.disruptor = disruptor;</span><br><span class="line">        <span class="keyword">this</span>.consumerRepository = consumerRepository;</span><br><span class="line">        <span class="keyword">this</span>.sequences = Arrays.copyOf(sequences, sequences.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> EventHandlerGroup&lt;T&gt; <span class="title">handleEventsWith</span><span class="params">(<span class="keyword">final</span> EventHandler&lt;? <span class="keyword">super</span> T&gt;... handlers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> disruptor.createEventProcessors(sequences, handlers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> EventHandlerGroup&lt;T&gt; <span class="title">then</span><span class="params">(<span class="keyword">final</span> EventHandler&lt;? <span class="keyword">super</span> T&gt;... handlers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handleEventsWith(handlers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> EventHandlerGroup 会拷贝一份 batchEventProcessor 中的 sequence<br> demo 例子中 disruptor.handleEventsWith(TestHandler).<code>then</code>(ThenHandler)<br> 通过 then 方法将 TestHandler 中的 sequence 传递给 ThenHandler<br> 这样 ThenHandler 就依赖了 TestHandler, ThenHandler 就会在 TestHandler 后执行</p></li></ol><h3 id="生产事件消息"><a href="#生产事件消息" class="headerlink" title="生产事件消息"></a>生产事件消息</h3><p>接着看 <code>disruptor.publishEvent(translator, i)</code> 就是往 ringBuffer 里面放数据,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;A&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(EventTranslatorOneArg&lt;E, A&gt; translator, A arg0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> sequence = sequencer.next();</span><br><span class="line">    translateAndPublish(translator, sequence, arg0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;A&gt; <span class="function"><span class="keyword">void</span> <span class="title">translateAndPublish</span><span class="params">(EventTranslatorOneArg&lt;E, A&gt; translator, <span class="keyword">long</span> sequence, A arg0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        translator.translateTo(get(sequence), sequence, arg0);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sequencer.publish(sequence);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">long</span> sequence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elementAt(sequence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get(sequence) 根据 sequence [ringbuffer 索引] 获取 ringbuffer 数组里的对象<br>translator 将其处理替换完后，ringbuffer 数组的的值将是新的值，publish 将会更新索引的标记位<br>waitStrategy.signalAllWhenBlocking() 会通知阻塞等待的消费者去继续消费消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Sequence cursor = <span class="keyword">new</span> Sequence(Sequencer.INITIAL_CURSOR_VALUE);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(<span class="keyword">long</span> sequence)</span> </span>&#123;</span><br><span class="line">    cursor.set(sequence);</span><br><span class="line">    waitStrategy.signalAllWhenBlocking();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>流程理清楚了，我们看看 知识点</p><ul><li><a href="https://blog.codingnow.com/2012/02/ring_buffer.html">ringbuffer</a><ul><li>内存使用率很高，不会造成内存碎片，几乎没有浪费。业务处理的同一时间，访问的内存数据段集中。<br>可以更好的适应不同系统，取得较高的性能。内存的物理布局简单单一，不太容易发生内存越界、悬空指针等 bug，出了问题也容易在内存级别分析调试。<br>做出来的系统容易保持健壮。</li></ul></li><li><a href="https://cloud.tencent.com/developer/article/1164096">cpu cache</a><ul><li>CPU 访问内存时会等待，导致计算资源大量闲置，降低 CPU 整体吞吐量。<br>由于内存数据访问的热点集中性，在 CPU 和内存之间用较为快速而成本较高（相对于内存）的介质做一层缓存，就显得性价比极高了 </li></ul></li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul><li><p>distruptor 框架导致 CPU 高</p><ul><li><p>当消费者的消费速度大于生产者时，消费者有不同的 WaitStrategy 进行等待, 构建 disruptor 的时候，可以指定等待策略</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">Disruptor</span>[<span class="type">Event</span>](factory, <span class="number">4</span>, threadFactory, <span class="type">ProducerType</span>.<span class="type">SINGLE</span>, <span class="keyword">new</span> <span class="type">BlockingWaitStrategy</span>())</span><br></pre></td></tr></table></figure><p>下面是 WaitStrategy 的一些实现类的简介 <strong>对应类上的comment</strong></p><ul><li>BusySpinWaitStrategy<ul><li>将线程绑定在 CPU 核上，减少线程切换，轮训获取 ringbuffer 上的数据</li></ul></li><li>PhasedBackoffWaitStrategy<ul><li>通过先自旋，后 yield 让出 CPU，最后通过自定义的 fallbackStrategy 来实现当代</li></ul></li><li>BlockingWaitStrategy<ul><li>通过 lock 来实现等待，ringbuffer中有消息后 会通过 signalAll 来唤起锁进行消费</li></ul></li><li>TimeoutBlockingWaitStrategy<ul><li>通过带有超时时间的 lock 来实现等待，过了超时时间会 throw exception</li></ul></li><li>SleepingWaitStrategy<ul><li>通过先自旋，后 yield 让出 CPU，最后 lock 的方式来进行等待，这个锁可以减少锁的唤起带来的损耗</li></ul></li><li>YieldingWaitStrategy<ul><li>通过先自旋，后 yield 让出 CPU 的方式来进行等待</li></ul></li></ul></li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://github.com/LMAX-Exchange/disruptor/wiki/Introduction">https://github.com/LMAX-Exchange/disruptor/wiki/Introduction</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> disruptor </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Classloader 是怎么工作的</title>
      <link href="2019/08/06/how-classloader-works.html"/>
      <url>2019/08/06/how-classloader-works.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>工作需要将多个 Playframework 的应用 在一个 java 进程中跑起来<br>Java 出身的我自然的想到 tomcat 可以运行多个 war，也就等同于多个 Playframework 在一个 Java 进程中跑起来</p><h2 id="Tomcat-如何运行多个-War"><a href="#Tomcat-如何运行多个-War" class="headerlink" title="Tomcat 如何运行多个 War"></a>Tomcat 如何运行多个 War</h2><p>首先通过 Tomcat 的 startup.sh 跳到 catalina.sh，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eval $_NOHUP &quot;\&quot;$_RUNJAVA\&quot;&quot; &quot;\&quot;$LOGGING_CONFIG\&quot;&quot; $LOGGING_MANAGER $JAVA_OPTS $CATALINA_OPTS \</span><br><span class="line"><span class="meta">  -D$</span><span class="bash">ENDORSED_PROP=<span class="string">&quot;\&quot;<span class="variable">$JAVA_ENDORSED_DIRS</span>\&quot;&quot;</span> \</span></span><br><span class="line"><span class="bash">  -classpath <span class="string">&quot;\&quot;<span class="variable">$CLASSPATH</span>\&quot;&quot;</span> \</span></span><br><span class="line"><span class="bash">  -Dcatalina.base=<span class="string">&quot;\&quot;<span class="variable">$CATALINA_BASE</span>\&quot;&quot;</span> \</span></span><br><span class="line"><span class="bash">  -Dcatalina.home=<span class="string">&quot;\&quot;<span class="variable">$CATALINA_HOME</span>\&quot;&quot;</span></span> </span><br><span class="line">  -Djava.io.tmpdir=&quot;\&quot;$CATALINA_TMPDIR\&quot;&quot; \</span><br><span class="line">  org.apache.catalina.startup.Bootstrap &quot;$@&quot; start \</span><br><span class="line"><span class="meta">  &gt;</span><span class="bash">&gt; <span class="string">&quot;<span class="variable">$CATALINA_OUT</span>&quot;</span> 2&gt;&amp;1 <span class="string">&quot;&amp;&quot;</span></span></span><br></pre></td></tr></table></figure><p>进入 org.apache.catalina.startup.Bootstrap 这个 tomcat 的启动入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    initClassLoaders();</span><br><span class="line"></span><br><span class="line">    Thread.currentThread().setContextClassLoader(catalinaLoader);</span><br><span class="line"></span><br><span class="line">    SecurityClassLoad.securityClassLoad(catalinaLoader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load our startup class and call its process() method</span></span><br><span class="line">    Class&lt;?&gt; startupClass = catalinaLoader.loadClass(<span class="string">&quot;org.apache.catalina.startup.Catalina&quot;</span>);</span><br><span class="line">    Object startupInstance = startupClass.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the shared extensions class loader</span></span><br><span class="line">    String methodName = <span class="string">&quot;setParentClassLoader&quot;</span>;</span><br><span class="line">    Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">    paramTypes[<span class="number">0</span>] = Class.forName(<span class="string">&quot;java.lang.ClassLoader&quot;</span>);</span><br><span class="line">    Object paramValues[] = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">    paramValues[<span class="number">0</span>] = sharedLoader;</span><br><span class="line">    Method method = startupInstance.getClass().getMethod(methodName, paramTypes);</span><br><span class="line">    method.invoke(startupInstance, paramValues);</span><br><span class="line"></span><br><span class="line">    catalinaDaemon = startupInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initClassLoaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        commonLoader = createClassLoader(<span class="string">&quot;common&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (commonLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// no config file, default to this loader - we might be in a &#x27;single&#x27; env.</span></span><br><span class="line">            commonLoader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        catalinaLoader = createClassLoader(<span class="string">&quot;server&quot;</span>, commonLoader);</span><br><span class="line">        sharedLoader = createClassLoader(<span class="string">&quot;shared&quot;</span>, commonLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        handleThrowable(t);</span><br><span class="line">        log.error(<span class="string">&quot;Class loader creation threw exception&quot;</span>, t);</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bootstrap 中的 调用 Init 初始化了 catalinaLoader 和 sharedLoader 是 commonClassLoder 的子类  </p><ul><li>commonClassloader <ul><li>catalinaLoader</li><li>sharedLoader </li></ul></li></ul><p>然后看 Bootstrap.start, 实际上是 org.apache.catalina.startup.Catalina.start()<br>start() 会先 load Server, 将 tomcat 一系列的复杂组件进行初始化操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动 tomcat 组件的初始化方法，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initDirs();</span><br><span class="line">    initNaming();</span><br><span class="line">    File file = configFile();</span><br><span class="line">    Digester digester = createStartDigester();</span><br><span class="line">    getServer().setCatalina(<span class="keyword">this</span>);</span><br><span class="line">    getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());</span><br><span class="line">    getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stream redirection</span></span><br><span class="line">    initStreams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the new server</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getServer().init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.Error(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">&quot;catalina.initError&quot;</span>), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Digester <span class="title">createStartDigester</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Digester digester = <span class="keyword">new</span> Digester();</span><br><span class="line">    digester.setValidating(<span class="keyword">false</span>);</span><br><span class="line">    digester.setRulesValidation(<span class="keyword">true</span>);</span><br><span class="line">    Map&lt;Class&lt;?&gt;, List&lt;String&gt;&gt; fakeAttributes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; objectAttrs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    objectAttrs.add(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">    fakeAttributes.put(Object.class, objectAttrs);</span><br><span class="line">    <span class="comment">// Ignore attribute added by Eclipse for its internal tracking</span></span><br><span class="line">    List&lt;String&gt; contextAttrs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    contextAttrs.add(<span class="string">&quot;source&quot;</span>);</span><br><span class="line">    fakeAttributes.put(StandardContext.class, contextAttrs);</span><br><span class="line">    digester.setFakeAttributes(fakeAttributes);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> digester;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Start a new server instance.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        load(); </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Start the new server</span></span><br><span class="line">    getServer().start();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (await) &#123;</span><br><span class="line">        await();</span><br><span class="line">        stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    getServer().init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getServer().init() 的逻辑 在 Server 的子类 StandardServer 中实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleBase</span> <span class="keyword">implements</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">            invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            setStateInternal(LifecycleState.INITIALIZING, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">            initInternal();</span><br><span class="line">            setStateInternal(LifecycleState.INITIALIZED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleSubClassException(t, <span class="string">&quot;lifecycleBase.initFail&quot;</span>, toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LifecycleMBeanBase extends LifecycleBase </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardServer</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">      <span class="comment">// Populate the extension validator with JARs from common and shared</span></span><br><span class="line">      <span class="comment">// class loaders</span></span><br><span class="line">      <span class="keyword">if</span> (getCatalina() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          ClassLoader cl = getCatalina().getParentClassLoader();</span><br><span class="line">          <span class="comment">// Walk the class loader hierarchy. Stop at the system class loader.</span></span><br><span class="line">          <span class="comment">// This will add the shared (if present) and common class loaders</span></span><br><span class="line">          <span class="keyword">while</span> (cl != <span class="keyword">null</span> &amp;&amp; cl != ClassLoader.getSystemClassLoader()) &#123;</span><br><span class="line">              <span class="keyword">if</span> (cl <span class="keyword">instanceof</span> URLClassLoader) &#123;</span><br><span class="line">                  URL[] urls = ((URLClassLoader) cl).getURLs();</span><br><span class="line">                  <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (url.getProtocol().equals(<span class="string">&quot;file&quot;</span>)) &#123;</span><br><span class="line">                          <span class="keyword">try</span> &#123;</span><br><span class="line">                              File f = <span class="keyword">new</span> File (url.toURI());</span><br><span class="line">                              <span class="keyword">if</span> (f.isFile() &amp;&amp; f.getName().endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">                                  ExtensionValidator.addSystemResource(f);</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">                              <span class="comment">// Ignore</span></span><br><span class="line">                          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                              <span class="comment">// Ignore</span></span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              cl = cl.getParent();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StandardServer.init 逻辑实际是 继承自 LifecycleBase 并调用 自己的 initInternal<br>StandardServer.getCatalina().getParentClassLoader(); 实际上获取的就是 在 Catalina.load 过程中 设置的 Catalina 实例的属性 parentClassLoader<br>注释上写的很好，就是用 Catalina 里的 commonClassLoader 和 sharedClassLoader 去加载资源</p><p>接着看 StandardContext </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class ContainerBase extends LifecycleMBeanBase</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardContext</span> <span class="keyword">extends</span> <span class="title">ContainerBase</span> <span class="keyword">implements</span> <span class="title">Context</span>, <span class="title">NotificationEmitter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (getLoader() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            WebappLoader webappLoader = <span class="keyword">new</span> WebappLoader(getParentClassLoader());</span><br><span class="line">            webappLoader.setDelegate(getDelegate());</span><br><span class="line">            setLoader(webappLoader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Binding thread</span></span><br><span class="line">        ClassLoader oldCCL = bindThread();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                <span class="comment">// Start our subordinate components, if any</span></span><br><span class="line">                Loader loader = getLoader();</span><br><span class="line">                <span class="keyword">if</span> (loader <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">                    ((Lifecycle) loader).start();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// By calling unbindThread and bindThread in a row, we setup the</span></span><br><span class="line">                <span class="comment">// current Thread CCL to be the webapp classloader</span></span><br><span class="line">                unbindThread(oldCCL);</span><br><span class="line">                oldCCL = bindThread();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Unbinding thread</span></span><br><span class="line">            unbindThread(oldCCL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ClassLoader <span class="title">bindThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassLoader oldContextClassLoader = bind(<span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isUseNaming()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ContextBindings.bindThread(<span class="keyword">this</span>, getNamingToken());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">                <span class="comment">// Silent catch, as this is a normal case during the early</span></span><br><span class="line">                <span class="comment">// startup stages</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldContextClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">bind</span><span class="params">(<span class="keyword">boolean</span> usePrivilegedAction, ClassLoader originalClassLoader)</span> </span>&#123;</span><br><span class="line">        Loader loader = getLoader();</span><br><span class="line">        ClassLoader webApplicationClassLoader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            webApplicationClassLoader = loader.getClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (originalClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (usePrivilegedAction) &#123;</span><br><span class="line">                PrivilegedAction&lt;ClassLoader&gt; pa = <span class="keyword">new</span> PrivilegedGetTccl();</span><br><span class="line">                originalClassLoader = AccessController.doPrivileged(pa);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                originalClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (webApplicationClassLoader == <span class="keyword">null</span> ||</span><br><span class="line">                webApplicationClassLoader == originalClassLoader) &#123;</span><br><span class="line">            <span class="comment">// Not possible or not necessary to switch class loaders. Return</span></span><br><span class="line">            <span class="comment">// null to indicate this.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ThreadBindingListener threadBindingListener = getThreadBindingListener();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (usePrivilegedAction) &#123;</span><br><span class="line">            PrivilegedAction&lt;Void&gt; pa = <span class="keyword">new</span> PrivilegedSetTccl(webApplicationClassLoader);</span><br><span class="line">            AccessController.doPrivileged(pa);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Thread.currentThread().setContextClassLoader(webApplicationClassLoader);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (threadBindingListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                threadBindingListener.bind();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                ExceptionUtils.handleThrowable(t);</span><br><span class="line">                log.error(sm.getString(</span><br><span class="line">                        <span class="string">&quot;standardContext.threadBindingListenerError&quot;</span>, getName()), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> originalClassLoader;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心逻辑就是 利用 Thread.currentThread().setContextClassLoader(webApplicationClassLoader) 来改变当前线程上下文中的 classloader 实例<br>通过 WebappClassLoader.start() 去加载 每个 war 里面的资源 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    state = LifecycleState.STARTING_PREP;</span><br><span class="line"></span><br><span class="line">    WebResource[] classesResources = resources.getResources(<span class="string">&quot;/WEB-INF/classes&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (WebResource classes : classesResources) &#123;</span><br><span class="line">        <span class="keyword">if</span> (classes.isDirectory() &amp;&amp; classes.canRead()) &#123;</span><br><span class="line">            localRepositories.add(classes.getURL());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    WebResource[] jars = resources.listResources(<span class="string">&quot;/WEB-INF/lib&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (WebResource jar : jars) &#123;</span><br><span class="line">        <span class="keyword">if</span> (jar.getName().endsWith(<span class="string">&quot;.jar&quot;</span>) &amp;&amp; jar.isFile() &amp;&amp; jar.canRead()) &#123;</span><br><span class="line">            localRepositories.add(jar.getURL());</span><br><span class="line">            jarModificationTimes.put(</span><br><span class="line">                    jar.getName(), Long.valueOf(jar.getLastModified()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state = LifecycleState.STARTED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Classloader 可有效的将 class 资源进行隔离</li><li>Class.getClass.getClassLoader 获取的是加载 这个 class 的 classLoader</li><li>Thread.currentThread().getClassLoader() 获取的是当前线程上下文的 classloader</li><li>Thread.currentThread().setClassLoader(自定义classLoader) 可加载指定的 class 资源</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> tomcat </tag>
            
            <tag> classloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Threadlocal 源码阅读</title>
      <link href="2019/07/29/threadlocal.html"/>
      <url>2019/07/29/threadlocal.html</url>
      
        <content type="html"><![CDATA[<h2 id="ThreadLocal-是什么"><a href="#ThreadLocal-是什么" class="headerlink" title="ThreadLocal 是什么"></a>ThreadLocal 是什么</h2><p>threadlocal 可为每个线程存储一份单独的变量，threadlocal 里面的值 线程之间不共享 </p><p>使用方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">local.set(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">String localValue = local.get()</span><br><span class="line"></span><br><span class="line">local.remove()</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal-如何保证线程间不可见"><a href="#ThreadLocal-如何保证线程间不可见" class="headerlink" title="ThreadLocal 如何保证线程间不可见"></a>ThreadLocal 如何保证线程间不可见</h2><h3 id="ThreadLocal-set"><a href="#ThreadLocal-set" class="headerlink" title="ThreadLocal.set"></a>ThreadLocal.set</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value); <span class="comment">//将 this(指向 ThreadLocal) 和 value 组对 放进去</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value); <span class="comment">//则初始化一个 跟 t(当前线程) 相关的 ThreadLocalMap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看 createMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 Thread 内部有个 ThreadLocalMap 类型的属性 t.threadLocals，并且实例化 一个 ThreadLocal 和 value 组对 的 ThreadLocalMap<br>接着看 ThreadLocalMap 的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap 初始化一个 Entry 的数组,并算了 ThreadLocal 的一个 hash 值作为 table 的数组索引，将 Entry 对象放到数组的指定位置上</p><p>Entry 为 WeakReference 类型，可以保证当Entry 里的 value 对象被除WeakReference对象之外所有的对象解除引用后，该 value 对象便可以被GC回收</p><p>接着 回去看 map.set(this, value);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">          e != <span class="keyword">null</span>;</span><br><span class="line">          e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿着 ThreadLocal 类型的 key的 hashcode 去 Entry 数组里面找索引，拿到 value(tab[i]), 如果索引值存在就拿新 value 换旧值</p><p>for 循环里面的 if (k == key) 之后的代码，应该就是 注释里面解释的，对一个 新的 ThreadLocal 的处理逻辑</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// We don&#x27;t use a fast path as with get() because it is at</span><br><span class="line">// least as common to use set() to create new entries as</span><br><span class="line">// it is to replace existing ones, in which case, a fast</span><br><span class="line">// path would fail more often than not.</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal-get"><a href="#ThreadLocal-get" class="headerlink" title="ThreadLocal.get"></a>ThreadLocal.get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑就是拿到 当前 Thread 的 threadLocalMap，通过 map.getEntry(this) 拿到 与 threadlocal 成对的 value值</p><h3 id="ThreadLocal-remove"><a href="#ThreadLocal-remove" class="headerlink" title="ThreadLocal.remove"></a>ThreadLocal.remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal.remove</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadLocalMap.remove</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">          e != <span class="keyword">null</span>;</span><br><span class="line">          e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取当前 Thread 的 threadlocalMap 并对其内部的 Entry 数组 遍历置为 null，便于被 GC 掉</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>ThreadLocal 通过操作 Thread 内部的 ThreadLocalMap 来达到线程之间隔离</p></li><li><p>ThreadLocal 跟线程绑定，线程执行完，ThreadLocal 会被GC 掉，由于线程池中的线程生命周期长，所以 使用 ThreadLocal 要注意 TreadLocal.remove 操作</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala 调用链追踪</title>
      <link href="2019/04/24/scala-call-chain-trace.html"/>
      <url>2019/04/24/scala-call-chain-trace.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>分布式服务系统中，通过透传一个 traceId，就可以做到链路追踪<br>服务与服务之间调用链路可以很清晰的描述出服务与服务之间的依赖关系<br>但是 系统内部如何 把 这个 traceId 在线程之间传递，并封装在返回结果中？</p><h2 id="实现调用链"><a href="#实现调用链" class="headerlink" title="实现调用链"></a>实现调用链</h2><p>如果是同步调用，一个线程处理所有请求，此时可以用跟 线程绑定的 <a href="/2019/07/29/threadlocal.html" title="ThreadLocal">ThreadLocal</a> 来实现, 这个很好理解</p><p>如果是异步调用，一个事务处理逻辑中会有多个线程参与执行，我们得想办法 将 threadLocal 在多个线程之间进行传递</p><p>先看下 scala 中 如何实现 异步, Future 的详细实现 可参考 <a href="/2019/03/30/scala-future.html" title="Scala Future 异步工具类解读">Scala Future 异步工具类解读</a></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</span><br><span class="line"></span><br><span class="line"><span class="type">Future</span> &#123;</span><br><span class="line">  println(<span class="string">&quot;hh&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>概括来讲， Future的执行 实际上是 交给 ExecutionContext.execute 去做的</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[scala] <span class="class"><span class="keyword">class</span> <span class="title">ExecutionContextImpl</span> <span class="title">private</span>[impl] (<span class="params">val executor: java.util.concurrent.<span class="type">Executor</span>, val reporter: <span class="type">Throwable</span> =&gt; <span class="type">Unit</span></span>) <span class="keyword">extends</span> <span class="title">ExecutionContextExecutor</span> </span>&#123;</span><br><span class="line">  require(executor ne <span class="literal">null</span>, <span class="string">&quot;Executor must not be null&quot;</span>)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">execute</span></span>(runnable: <span class="type">Runnable</span>) = executor execute runnable</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reportFailure</span></span>(t: <span class="type">Throwable</span>) = reporter(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>executor execute runnable 就是把 Future 的任务 转变成 Runable 去交给底层的 线程池去执行<br>大部分的 Java 的业务系统都是扩展了 Java 底层线程池的逻辑</p><p>但是 Scala 已经 抽象出一层 ExecutionContext, 通过实现 ExecutionContext 的一个子类，来重写 execute 方法, 把 ExecutionContext.execute 之前的线程的 threadlocal 传给 执行 execute 的线程就 Ok了</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceExecuteContext</span>(<span class="params">executionContext: <span class="type">ExecutionContext</span></span>) <span class="keyword">extends</span> <span class="title">ExecutionContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">execute</span></span>(runnable: <span class="type">Runnable</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> currentThread = <span class="type">ThreadContextUtil</span>.getContext</span><br><span class="line">    executionContext.execute(<span class="keyword">new</span> <span class="type">Runnable</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        currentThread.foreach(thread =&gt; <span class="type">ThreadContextUtil</span>.copyContext(thread.copy(tid = <span class="type">Thread</span>.currentThread().getId.toString)))</span><br><span class="line">        runnable.run()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reportFailure</span></span>(cause: <span class="type">Throwable</span>): <span class="type">Unit</span> = executionContext.reportFailure(cause)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="Play-Framework"><a href="#Play-Framework" class="headerlink" title="Play Framework"></a>Play Framework</h3><p>playframework2.6 底层基于 Akka 实现，我们需要替换掉 akka 的 ExecutionContext</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TracePropagatingDispatcher</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    config: <span class="type">MessageDispatcherConfigurator</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    id: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    throughput: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    throughputDeadlineTime: <span class="type">Duration</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    executorServiceFactoryProvider: <span class="type">ExecutorServiceFactoryProvider</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    shutdownTimeout: <span class="type">FiniteDuration</span></span>)</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Dispatcher</span>(<span class="params">config, id, throughput, throughputDeadlineTime, executorServiceFactoryProvider, shutdownTimeout</span>) </span>&#123;</span><br><span class="line">  self =&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">prepare</span></span>(): <span class="type">ExecutionContext</span> = <span class="type">TraceExecuteContext</span>.traceExecuteContext</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reportFailure</span></span>(t: <span class="type">Throwable</span>): <span class="type">Unit</span> = self.reportFailure(t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TracePropagatingDispatcherConfigurator</span>(<span class="params">config: <span class="type">Config</span>, prerequisites: <span class="type">DispatcherPrerequisites</span></span>) <span class="keyword">extends</span> <span class="title">MessageDispatcherConfigurator</span>(<span class="params">config, prerequisites</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> instance = <span class="keyword">new</span> <span class="type">TracePropagatingDispatcher</span>(</span><br><span class="line">    <span class="keyword">this</span>,</span><br><span class="line">    config.getString(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">    config.getInt(<span class="string">&quot;throughput&quot;</span>),</span><br><span class="line">    config.getDuration(<span class="string">&quot;throughput-deadline-time&quot;</span>, <span class="type">TimeUnit</span>.<span class="type">NANOSECONDS</span>).nanosecond,</span><br><span class="line">    configureExecutor(),</span><br><span class="line">    config.getDuration(<span class="string">&quot;shutdown-timeout&quot;</span>, <span class="type">TimeUnit</span>.<span class="type">MICROSECONDS</span>).millisecond</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">dispatcher</span></span>(): <span class="type">MessageDispatcher</span> = instance</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 reference.conf 里面 配置 akka 的 default-dispatcher 为 TracePropagatingDispatcherConfigurator </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">akka &#123;</span><br><span class="line">  actor &#123;</span><br><span class="line">    default-dispatcher &#x3D; &#123;</span><br><span class="line">      type &#x3D; &quot;io.github.wtog.strace.akka.TracePropagatingDispatcherConfigurator&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数式编程 天然适合做 AOP，Play 的 Filter 基于此，可以拦截到所有请求，可以在 filter 里面 将 traceId 初始化，这样 就可以将外部的 traceid，传给内部</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraceFilter</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">configuration: <span class="type">Configuration</span></span>)(<span class="params">implicit override val mat: <span class="type">Materializer</span>, ec: <span class="type">TraceExecuteContext</span></span>) <span class="keyword">extends</span> <span class="title">LazyLogging</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(f: <span class="type">RequestHeader</span> =&gt; <span class="type">Future</span>[<span class="type">Result</span>])(rh: <span class="type">RequestHeader</span>): <span class="type">Future</span>[<span class="type">Result</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> traceId = rh.headers.get(<span class="string">&quot;traceId&quot;</span>)</span><br><span class="line">    <span class="type">ThreadContextUtil</span>(traceId)</span><br><span class="line">    f(rh).map &#123;r =&gt;</span><br><span class="line">      <span class="type">ThreadContextUtil</span>.cleanContext()</span><br><span class="line">      r.withHeaders(<span class="string">&quot;traceId&quot;</span> -&gt; traceId)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码地址 <a href="https://github.com/wtog/strace">https://github.com/wtog/strace</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
            <tag> 调用链追踪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jstack 解读</title>
      <link href="2019/04/11/jstack.html"/>
      <url>2019/04/11/jstack.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java-中线程的状态"><a href="#Java-中线程的状态" class="headerlink" title="Java 中线程的状态"></a>Java 中线程的状态</h2><ul><li><p>NEW 初始状态。</p><ul><li>线程刚刚被创建，并且start()方法还未被调用</li></ul></li><li><p>RUNNABLE 运行状态。</p><ul><li>表示线程正在java虚拟机中执行，但是可能正在等待操作系统的其他资源，比如CPU</li></ul></li><li><p>BLOCKED 阻塞状态。</p><ul><li>表示线程正在等待监视器锁。表示线程正在等待获取监视器锁，以便进入同步方法或者同步代码快，也有可能是从wait（）方法被唤醒而等待再次进入同步方法或者同步代码块</li></ul></li><li><p>WAITING 等待状态。</p><ul><li>表示当前线程需要等待其他线程执行一些特殊操作，比如当前线程调用了a.wait()方法，它正在等待其他线程调用a.notify或a.notifyAll方法;如果当前线程调用了threada.join(),那么它在等待thread a执行完成</li><li><strong>触发条件</strong>  <ul><li>Object.wait() 不设置超时时间</li><li>Thread.join() 不设置超时时间</li><li>LockSupport.park() 不设置超时时间</li></ul></li></ul></li><li><p>TIMED_WAITING 超时等待。</p><ul><li>与WAITING的不同在于，该状态有超时时间</li><li><strong>触发条件</strong><ul><li>Object.wait(time)</li><li>Thread.join(time)</li><li>Thread.sleep(time)</li><li>LockSupport.parkNanos(time)</li><li>LockSupport.parkUntil(time)</li></ul></li></ul></li><li><p>TERMINATED 终止状态</p><ul><li>表示当前线程已经执行完毕</li></ul></li></ul><h2 id="统计-jstack-中各个状态的线程数量-slick-dead-线程堆栈文件"><a href="#统计-jstack-中各个状态的线程数量-slick-dead-线程堆栈文件" class="headerlink" title="统计 jstack 中各个状态的线程数量 slick-dead: 线程堆栈文件"></a>统计 jstack 中各个状态的线程数量 <em>slick-dead: 线程堆栈文件</em></h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: <span class="string">&#x27;/java.lang.Thread.State/ &#123;c[$2]++&#125;; END &#123;for(t in c) print t, c[t]&#125;&#x27;</span> slick-dead | sort -rn -k <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="排查-CPU-高"><a href="#排查-CPU-高" class="headerlink" title="排查 CPU 高"></a>排查 CPU 高</h2><ol><li><p>找到 java 进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br><span class="line"></span><br><span class="line">info</span><br><span class="line"></span><br><span class="line">3186 Kafka</span><br><span class="line">2789 QuorumPeerMain</span><br><span class="line">6056 ApiBootstrap</span><br><span class="line">27640 Jps</span><br></pre></td></tr></table></figure></li><li><p>找到占用CPU 高的 java 线程ID</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">top -H -p JAVA_PID</span><br><span class="line"></span><br><span class="line">info</span><br><span class="line"></span><br><span class="line">top - 11:58:21 up 1 day,  2:42,  2 users,  load average: 5.53, 5.71, 5.67</span><br><span class="line">Threads:  40 total,   9 running,  31 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu(s): 38.3 us, 25.0 sy,  0.0 ni, 35.0 id,  0.0 wa,  0.0 hi,  0.0 si,  1.7 st</span></span><br><span class="line">KiB Mem : 16235220 total, 14041692 free,  1565180 used,   628348 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used. 14347812 avail Mem</span><br><span class="line"></span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">6103 apps      20   0 7850124 378852  21004 S 33.3  2.3 328:41.42 java</span><br><span class="line">6091 apps      20   0 7850124 378852  21004 R 26.7  2.3 363:05.92 java</span><br><span class="line">6092 apps      20   0 7850124 378852  21004 R 26.7  2.3 356:59.78 java</span><br><span class="line">6096 apps      20   0 7850124 378852  21004 R 26.7  2.3 329:02.12 java</span><br><span class="line">6104 apps      20   0 7850124 378852  21004 S 26.7  2.3 334:30.68 java</span><br><span class="line">6105 apps      20   0 7850124 378852  21004 R 26.7  2.3 333:58.77 java</span><br><span class="line">6094 apps      20   0 7850124 378852  21004 R 20.0  2.3 324:20.23 java</span><br><span class="line">6095 apps      20   0 7850124 378852  21004 R 20.0  2.3 332:13.38 java</span><br><span class="line">6100 apps      20   0 7850124 378852  21004 S 20.0  2.3 368:29.35 java</span><br><span class="line">6101 apps      20   0 7850124 378852  21004 R 20.0  2.3 337:29.08 java</span><br><span class="line">6102 apps      20   0 7850124 378852  21004 R 20.0  2.3 327:07.27 java</span><br><span class="line">6093 apps      20   0 7850124 378852  21004 R 13.3  2.3 325:53.33 java</span><br></pre></td></tr></table></figure></li><li><p>保存 jvm 线程堆栈</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack -l JAVA_PID &gt; /tmp/stack.JAVA_PID</span><br></pre></td></tr></table></figure></li><li><p>根据 TOP 展示的 高CPU线程ID，找到 jstack 中 对应的 java 代码块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> cat /tmp/api.6056 | grep `printf %x JAVA_PID` -A 20</span><br><span class="line"></span><br><span class="line"> info</span><br><span class="line"></span><br><span class="line"> &quot;log2kafka-worker-3&quot; #27 prio=5 os_prio=0 tid=0x00007fce6e2c3000 nid=0x17d7 runnable [0x00007fce526e5000]</span><br><span class="line">  java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line"> at sun.misc.Unsafe.park(Native Method)</span><br><span class="line"> at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:338)</span><br><span class="line"> at com.lmax.disruptor.SleepingWaitStrategy.applyWaitMethod(SleepingWaitStrategy.java:92)</span><br><span class="line"> at com.lmax.disruptor.SleepingWaitStrategy.waitFor(SleepingWaitStrategy.java:65)</span><br><span class="line"> at com.lmax.disruptor.ProcessingSequenceBarrier.waitFor(ProcessingSequenceBarrier.java:56)</span><br><span class="line"> at com.lmax.disruptor.BatchEventProcessor.processEvents(BatchEventProcessor.java:159)</span><br><span class="line"> at com.lmax.disruptor.BatchEventProcessor.run(BatchEventProcessor.java:125)</span><br><span class="line"> at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line">  Locked ownable synchronizers:</span><br><span class="line"> - None</span><br><span class="line"></span><br><span class="line">&quot;log2kafka-worker-2&quot; #26 prio=5 os_prio=0 tid=0x00007fce6e2c1000 nid=0x17d6 runnable [0x00007fce527e6000]</span><br><span class="line">  java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line"> at sun.misc.Unsafe.park(Native Method)</span><br><span class="line"> at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:338)</span><br><span class="line"> at com.lmax.disruptor.SleepingWaitStrategy.applyWaitMethod(SleepingWaitStrategy.java:92)</span><br><span class="line"> at com.lmax.disruptor.SleepingWaitStrategy.waitFor(SleepingWaitStrategy.java:65)</span><br><span class="line"> at com.lmax.disruptor.ProcessingSequenceBarrier.waitFor(ProcessingSequenceBarrier.java:56) </span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jstack </tag>
            
            <tag> awk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL 常用命令</title>
      <link href="2019/04/05/postgre-sql.html"/>
      <url>2019/04/05/postgre-sql.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>查询是否锁表了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">oid</span> <span class="keyword">from</span> pg_class <span class="keyword">where</span> relname=<span class="string">&#x27;可能锁表了的表&#x27;</span></span><br><span class="line"><span class="keyword">select</span> pid <span class="keyword">from</span> pg_locks <span class="keyword">where</span> relation=<span class="string">&#x27;上面查出的oid&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>释放锁定表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> pg_cancel_backend(pg_locks.pid)</span><br></pre></td></tr></table></figure></li><li><p>索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> pg_indexes <span class="keyword">where</span> tablename <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">&#x27;pg%&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>查询表及表列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> table_name, string_agg(column_name, <span class="string">&#x27;, &#x27;</span>) <span class="keyword">as</span> <span class="keyword">columns</span> <span class="keyword">from</span> information_schema.columns <span class="keyword">group</span> <span class="keyword">by</span> table_name</span><br></pre></td></tr></table></figure></li><li><p>查询表列名，类型，注释</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.attname <span class="keyword">as</span> <span class="keyword">name</span>, col_description(a.attrelid,a.attnum) <span class="keyword">as</span> <span class="keyword">comment</span>,format_type(a.atttypid,a.atttypmod) <span class="keyword">as</span> <span class="keyword">type</span> <span class="keyword">FROM</span> pg_class <span class="keyword">as</span> c, pg_attribute <span class="keyword">as</span> a <span class="keyword">where</span> c.relname = <span class="string">&#x27;table_name&#x27;</span> <span class="keyword">and</span> a.attrelid = c.oid <span class="keyword">and</span> a.attnum &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>更新 Json 类型的字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> table_name <span class="keyword">set</span> json_column = jsonb_set(json_column::jsonb, <span class="string">&#x27;&#123;field&#125;&#x27;</span>, <span class="string">&#x27;field_value&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>生成随机字符串</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">function</span> random_string(<span class="keyword">length</span> <span class="built_in">integer</span>) <span class="keyword">returns</span> <span class="built_in">text</span> <span class="keyword">as</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">  chars <span class="built_in">text</span>[] := <span class="string">&#x27;&#123;0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z&#125;&#x27;</span>;</span><br><span class="line">  result text := &#x27;&#x27;;</span><br><span class="line">  i integer := 0;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">length</span> &lt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">raise</span> <span class="keyword">exception</span> <span class="string">&#x27;Given length cannot be less than 0&#x27;</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">  for i in 1..length loop</span><br><span class="line">    result := result || chars[1+random()*(array_length(chars, 1)-1)];</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line">  return result;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">$$ language plpgsql;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgre </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络连接状态统计</title>
      <link href="2019/04/04/network-statistics.html"/>
      <url>2019/04/04/network-statistics.html</url>
      
        <content type="html"><![CDATA[<h2 id="系统连接状态篇："><a href="#系统连接状态篇：" class="headerlink" title="系统连接状态篇："></a>系统连接状态篇：</h2><h3 id="查看TCP连接状态"><a href="#查看TCP连接状态" class="headerlink" title="查看TCP连接状态"></a>查看TCP连接状态</h3><ol><li><p>统计多种状态的网络连接数 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk &#x27;/^tcp/ &#123;++state[$NF]&#125;; END &#123;for(key in state) print key, state[key]&#125;&#x27;</span><br><span class="line"></span><br><span class="line">注释</span><br><span class="line">/^tcp/: 滤出tcp开头的记录，屏蔽udp,socket等无关记录。</span><br><span class="line">state[]: 相当于定义了一个名叫state的数组NF</span><br><span class="line">NF: 表示记录的字段数，如上所示的记录，NF等于6</span><br><span class="line"><span class="meta">$</span><span class="bash">NF: 表示某个字段的值，如上所示的记录，<span class="variable">$NF</span>也就是<span class="variable">$6</span>，表示第6个字段的值，也就是TIME_WAIT</span></span><br><span class="line"><span class="meta">state[$</span><span class="bash">NF] 表示数组元素的值，如上所示的记录，就是state[TIME_WAIT]状态的连接数</span></span><br><span class="line">++state[$NF]表示把某个数加一，如上所示的记录，就是把state[TIME_WAIT]状态的连接数加一</span><br><span class="line">END 表示在最后阶段要执行的命令</span><br><span class="line">for(key in state) 遍历数组 print key,&quot;\t&quot;,state[key] 打印数组的键和值，中间用\t制表符分割，美化一下。 </span><br></pre></td></tr></table></figure></li><li><p>查找请求数请20个IP（常用于查找攻来源）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ant | grep &quot;192.168.1.109&quot; | awk &#x27;&#123;print $5&#125;&#x27; | awk -F: &#x27;&#123;print $1&#125;&#x27;| uniq -c | sort -nr | head -20</span><br></pre></td></tr></table></figure></li><li><p>用tcpdump嗅探80端口的访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -tnn dst port 80-c 1000</span><br></pre></td></tr></table></figure></li><li><p>查找较多time_wait连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ant | awk &#x27;/TIME_WAIT/ &#123;print $5&#125;&#x27; | sort | uniq -c | sort -nr | head -20</span><br></pre></td></tr></table></figure></li><li><p>根据端口列进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntlp |grep 80|awk &#x27;&#123;print $7&#125;&#x27;|cut -d/-f1</span><br></pre></td></tr></table></figure></li></ol><h3 id="网站日志分析篇"><a href="#网站日志分析篇" class="headerlink" title="网站日志分析篇"></a>网站日志分析篇</h3><ol><li><p>获得访问前10位的ip地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /opt/logs/nginx-access.log | awk &#x27;&#123;print $1&#125;&#x27; | sort | uniq -c | sort -nr | head -n10</span><br><span class="line">cat /opt/logs/nginx-access.log | awk &#x27;&#123;counts[$(11)]+=1&#125;; END &#123;for(url in counts) print counts[url], url&#125;&#x27;</span><br></pre></td></tr></table></figure></li><li><p>访问次数最多的文件或页面,取前20</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /opt/log/nginx-access.log | awk &#x27;&#123;print $11&#125;&#x27; | sort | uniq -c | sort -nr | head -20</span><br></pre></td></tr></table></figure></li><li><p>列出传输最大的几个exe文件（分析下载站的时候常用）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /opt/log/nginx-access.log |awk &#x27;($7~/\.exe/)&#123;print $10 &quot; &quot; $1 &quot; &quot; $4 &quot; &quot; $7&#125;&#x27;|sort -nr|head -20</span><br></pre></td></tr></table></figure></li><li><p>列出输出大于200000byte(约200kb)的exe文件以及对应文件发生次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;opt&#x2F;log&#x2F;nginx-access.log |awk &#39;($10 &gt; 200000 &amp;&amp; $7~&#x2F;\.exe&#x2F;)&#123;print $7&#125;&#39;|sort -n|uniq -c|sort -nr|head -100</span><br></pre></td></tr></table></figure></li><li><p>列出最最耗时的页面(超过60秒的)的以及对应页面发生次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;opt&#x2F;log&#x2F;nginx-access.log |awk &#39;($NF &gt; 60 &amp;&amp; $7~&#x2F;\.php&#x2F;)&#123;print $7&#125;&#39;|sort -n|uniq -c|sort -nr|head -100</span><br></pre></td></tr></table></figure></li><li><p>列出传输时间超过 30 秒的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;opt&#x2F;log&#x2F;nginx-access.log |awk &#39;($NF &gt; 30)&#123;print $7&#125;&#39;|sort -n|uniq -c|sort -nr|head -20</span><br></pre></td></tr></table></figure></li><li><p>统计网站流量（G)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;opt&#x2F;log&#x2F;nginx-access.log |awk &#39;&#123;sum+&#x3D;$10&#125; END &#123;print sum&#x2F;1024&#x2F;1024&#x2F;1024&#125;&#39;</span><br></pre></td></tr></table></figure></li><li><p>统计404的连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#39;($9 ~&#x2F;404&#x2F;)&#39;&#x2F;opt&#x2F;log&#x2F;nginx-access.log |awk &#39;&#123;print $9,$7&#125;&#39;|sort</span><br></pre></td></tr></table></figure></li><li><p>统计http status.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;opt&#x2F;log&#x2F;nginx-access.log |awk &#39;&#123;counts[$(9)]+&#x3D;1&#125;; END &#123;for(code in counts) print code, counts[code]&#125;&#39;</span><br><span class="line">cat &#x2F;opt&#x2F;log&#x2F;nginx-access.log |awk &#39;&#123;print $9&#125;&#39;|sort|uniq -c|sort -rn</span><br><span class="line">cat &#x2F;opt&#x2F;logs&#x2F;nginx-access.log | awk &#39;&#123;if($9~&#x2F;200|30|404&#x2F;) COUNT[$7]++&#125; END &#123;for( a in COUNT) print a,COUNT[a]&#125;&#39; | sort -k 2 -n -r | head -n20</span><br></pre></td></tr></table></figure></li><li><p>每秒并发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;opt&#x2F;logs&#x2F;nginx-access.log | grep &#39;18&#x2F;Dec&#x2F;2017:18:25&#39; | wc -l | awk &#39;&#123;print $1&#x2F;60&#125;&#39;</span><br></pre></td></tr></table></figure></li></ol><h3 id="蜘蛛分析"><a href="#蜘蛛分析" class="headerlink" title="蜘蛛分析"></a>蜘蛛分析</h3><ol><li>查看是哪些蜘蛛在抓取内容。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -l -s 0-w -dst port 80 | strings | grep -i user-agent |grep -i -E &#39;bot|crawler|slurp|spider&#39;</span><br></pre></td></tr></table></figure></li></ol><h3 id="数据库篇"><a href="#数据库篇" class="headerlink" title="数据库篇"></a>数据库篇</h3><ol><li>查看数据库执行的sql<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -s 0-l -w -dst port 3306|strings |egrep -i &#39;SELECT|UPDATE|DELETE|INSERT|SET|COMMIT|ROLLBACK|CREATE|DROP|ALTER|CALL&#39;</span><br></pre></td></tr></table></figure><h3 id="系统Debug分析篇"><a href="#系统Debug分析篇" class="headerlink" title="系统Debug分析篇"></a>系统Debug分析篇</h3></li><li>调试命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -p pid</span><br></pre></td></tr></table></figure></li><li>跟踪指定进程的PID<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -p pid</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> dev-ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> awk </tag>
            
            <tag> netstat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Slick 死锁分析</title>
      <link href="2019/04/03/slick-deadlock.html"/>
      <url>2019/04/03/slick-deadlock.html</url>
      
        <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>  <strong>slick3.1</strong>版本中,并发执行带事务的DBIOAction, 线程会卡住, 导致DB连接被占满, 产生死锁。</p><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><ul><li><p>应用日志</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">2019-04-17 20:30:26.197 test [DEBUG] from slick.backend.DatabaseComponent.action in main - #1: schema.create [create table &quot;TEST&quot; (&quot;ID&quot; INTEGER NOT NULL)]</span><br><span class="line">2019-04-17 20:30:26.462 test [DEBUG] from slick.backend.DatabaseComponent.action in main - #2: SingleInsertAction [insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)]</span><br><span class="line">2019-04-17 20:30:26.464 test [DEBUG] from slick.jdbc.JdbcBackend.statement in h2mem1-1 - Preparing statement: insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)</span><br><span class="line">2019-04-17 20:30:26.466 test [DEBUG] from slick.backend.DatabaseComponent.action in main - #1: StartTransaction</span><br><span class="line">2019-04-17 20:30:26.467 test [DEBUG] from slick.backend.DatabaseComponent.action in h2mem1-2 - #2: SingleInsertAction [insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)]</span><br><span class="line">2019-04-17 20:30:26.468 test [DEBUG] from slick.jdbc.JdbcBackend.statement in h2mem1-2 - Preparing statement: insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)</span><br><span class="line">2019-04-17 20:30:26.468 test [DEBUG] from slick.backend.DatabaseComponent.action in main - #1: StartTransaction</span><br><span class="line">2019-04-17 20:30:26.471 test [DEBUG] from slick.backend.DatabaseComponent.action in h2mem1-2 - #2: SingleInsertAction [insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)]</span><br><span class="line">2019-04-17 20:30:26.471 test [DEBUG] from slick.jdbc.JdbcBackend.statement in h2mem1-2 - Preparing statement: insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)</span><br><span class="line">2019-04-17 20:30:26.474 test [DEBUG] from slick.backend.DatabaseComponent.action in main - #1: StartTransaction</span><br><span class="line">2019-04-17 20:30:26.475 test [DEBUG] from slick.backend.DatabaseComponent.action in h2mem1-1 - #2: SingleInsertAction [insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)]</span><br><span class="line">2019-04-17 20:30:26.475 test [DEBUG] from slick.jdbc.JdbcBackend.statement in h2mem1-2 - Preparing statement: insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)</span><br><span class="line">2019-04-17 20:30:26.476 test [DEBUG] from slick.backend.DatabaseComponent.action in main - #1: StartTransaction</span><br><span class="line">2019-04-17 20:30:26.479 test [DEBUG] from slick.backend.DatabaseComponent.action in h2mem1-1 - #2: SingleInsertAction [insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)]</span><br><span class="line">2019-04-17 20:30:26.480 test [DEBUG] from slick.jdbc.JdbcBackend.statement in h2mem1-2 - Preparing statement: insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)</span><br><span class="line">2019-04-17 20:30:26.485 test [DEBUG] from slick.backend.DatabaseComponent.action in main - #1: StartTransaction</span><br><span class="line">2019-04-17 20:30:26.488 test [DEBUG] from slick.backend.DatabaseComponent.action in h2mem1-1 - #2: SingleInsertAction [insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)]</span><br><span class="line">2019-04-17 20:30:26.488 test [DEBUG] from slick.jdbc.JdbcBackend.statement in h2mem1-2 - Preparing statement: insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)</span><br><span class="line">2019-04-17 20:30:26.492 test [DEBUG] from slick.backend.DatabaseComponent.action in main - #1: StartTransaction</span><br><span class="line">2019-04-17 20:30:26.495 test [DEBUG] from slick.backend.DatabaseComponent.action in main - #2: SingleInsertAction [insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)]</span><br><span class="line">2019-04-17 20:30:26.495 test [DEBUG] from slick.jdbc.JdbcBackend.statement in h2mem1-1 - Preparing statement: insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)</span><br><span class="line">2019-04-17 20:30:26.499 test [DEBUG] from slick.backend.DatabaseComponent.action in main - #1: StartTransaction</span><br><span class="line">2019-04-17 20:30:26.502 test [DEBUG] from slick.backend.DatabaseComponent.action in h2mem1-2 - #2: SingleInsertAction [insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)]</span><br><span class="line">2019-04-17 20:30:26.502 test [DEBUG] from slick.jdbc.JdbcBackend.statement in h2mem1-2 - Preparing statement: insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)</span><br><span class="line">2019-04-17 20:30:26.506 test [DEBUG] from slick.backend.DatabaseComponent.action in main - #1: StartTransaction</span><br><span class="line">2019-04-17 20:30:26.509 test [DEBUG] from slick.backend.DatabaseComponent.action in h2mem1-1 - #2: SingleInsertAction [insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)]</span><br><span class="line">2019-04-17 20:30:26.509 test [DEBUG] from slick.jdbc.JdbcBackend.statement in h2mem1-2 - Preparing statement: insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)</span><br><span class="line">2019-04-17 20:30:26.515 test [DEBUG] from slick.backend.DatabaseComponent.action in main - #1: StartTransaction</span><br><span class="line">2019-04-17 20:30:26.517 test [DEBUG] from slick.backend.DatabaseComponent.action in h2mem1-2 - #2: SingleInsertAction [insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)]</span><br><span class="line">2019-04-17 20:30:26.518 test [DEBUG] from slick.jdbc.JdbcBackend.statement in h2mem1-2 - Preparing statement: insert into &quot;TEST&quot; (&quot;ID&quot;)  values (?)</span><br><span class="line">2019-04-17 20:30:26.528 test [DEBUG] from slick.backend.DatabaseComponent.action in main - #1: StartTransaction</span><br><span class="line">2019-04-17 20:30:26.534 test [DEBUG] from slick.backend.DatabaseComponent.action in main - #1: StartTransaction</span><br><span class="line">2019-04-17 20:30:26.537 test [DEBUG] from slick.backend.DatabaseComponent.action in main - #1: StartTransaction</span><br><span class="line">2019-04-17 20:30:26.541 test [DEBUG] from slick.backend.DatabaseComponent.action in main - #1: StartTransaction</span><br><span class="line">2019-04-17 20:30:26.547 test [DEBUG] from slick.backend.DatabaseComponent.action in main - #1: StartTransaction</span><br><span class="line">waiting</span><br><span class="line">2019-04-17 20:30:26.644 test [DEBUG] from slick.backend.DatabaseComponent.action in ForkJoinPool-1-worker-7 - #3: result [select count(1) from &quot;TEST&quot;]</span><br><span class="line">2019-04-17 20:30:26.644 test [DEBUG] from slick.backend.DatabaseComponent.action in ForkJoinPool-1-worker-1 - #3: result [select count(1) from &quot;TEST&quot;]</span><br><span class="line">2019-04-17 20:30:26.644 test [DEBUG] from slick.backend.DatabaseComponent.action in ForkJoinPool-1-worker-5 - #3: result [select count(1) from &quot;TEST&quot;]</span><br><span class="line">2019-04-17 20:30:26.644 test [DEBUG] from slick.backend.DatabaseComponent.action in ForkJoinPool-1-worker-3 - #3: result [select count(1) from &quot;TEST&quot;]</span><br><span class="line">2019-04-17 20:30:26.648 test [DEBUG] from slick.backend.DatabaseComponent.action in ForkJoinPool-1-worker-7 - #3: result [select count(1) from &quot;TEST&quot;]</span><br><span class="line">2019-04-17 20:30:26.648 test [DEBUG] from slick.backend.DatabaseComponent.action in ForkJoinPool-1-worker-5 - #3: result [select count(1) from &quot;TEST&quot;]</span><br><span class="line">2019-04-17 20:30:26.649 test [DEBUG] from slick.backend.DatabaseComponent.action in ForkJoinPool-1-worker-3 - #3: result [select count(1) from &quot;TEST&quot;]</span><br><span class="line">2019-04-17 20:30:26.651 test [DEBUG] from slick.backend.DatabaseComponent.action in ForkJoinPool-1-worker-1 - #3: result [select count(1) from &quot;TEST&quot;]</span><br><span class="line">2019-04-17 20:30:26.652 test [DEBUG] from slick.backend.DatabaseComponent.action in ForkJoinPool-1-worker-7 - #3: result [select count(1) from &quot;TEST&quot;]</span><br><span class="line">2019-04-17 20:30:26.652 test [DEBUG] from slick.backend.DatabaseComponent.action in ForkJoinPool-1-worker-3 - #3: result [select count(1) from &quot;TEST&quot;]</span><br></pre></td></tr></table></figure><p>只有 StartTransaction，却没有 Commit</p></li><li><p>jstack 日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&quot;RMI TCP Connection(6)-192.168.0.100&quot; #32 daemon prio&#x3D;9 os_prio&#x3D;31 tid&#x3D;0x00007f8c01975800 nid&#x3D;0x6b03 runnable [0x0000700004c86000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line">  at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">  at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)</span><br><span class="line">  at java.net.SocketInputStream.read(SocketInputStream.java:170)</span><br><span class="line">  at java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br><span class="line">  at java.io.BufferedInputStream.fill(BufferedInputStream.java:246)</span><br><span class="line">  at java.io.BufferedInputStream.read(BufferedInputStream.java:265)</span><br><span class="line">  - locked &lt;merged&gt;(a java.io.BufferedInputStream)</span><br><span class="line">  at java.io.FilterInputStream.read(FilterInputStream.java:83)</span><br><span class="line">  at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:550)</span><br><span class="line">  at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:826)</span><br><span class="line">  at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$256(TCPTransport.java:683)</span><br><span class="line">  at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler$$Lambda$1&#x2F;672224267.run(Unknown Source)</span><br><span class="line">  at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">  at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:682)</span><br><span class="line">  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">  at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">  Locked ownable synchronizers:- &lt;merged&gt;(a java.util.concurrent.ThreadPoolExecutor$Worker)</span><br><span class="line"></span><br><span class="line">&quot;h2mem1-2&quot; #19 daemon prio&#x3D;5 os_prio&#x3D;31 tid&#x3D;0x00007f8bfe2f4000 nid&#x3D;0x1407 waiting on condition [0x0000700002d27000]</span><br><span class="line">  java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">  at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">  - parking to wait for  &lt;merged&gt;(a com.zaxxer.hikari.util.Java6ConcurrentBag$Synchronizer)</span><br><span class="line">  at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)</span><br><span class="line">  at java.util.concurrent.locks.AbstractQueuedLongSynchronizer.doAcquireSharedNanos(AbstractQueuedLongSynchronizer.java:815)</span><br><span class="line">  at java.util.concurrent.locks.AbstractQueuedLongSynchronizer.tryAcquireSharedNanos(AbstractQueuedLongSynchronizer.java:1106)</span><br><span class="line">  at com.zaxxer.hikari.util.ConcurrentBag.borrow(ConcurrentBag.java:134)</span><br><span class="line">  at com.zaxxer.hikari.pool.BaseHikariPool.getConnection(BaseHikariPool.java:201)</span><br><span class="line">  at com.zaxxer.hikari.pool.BaseHikariPool.getConnection(BaseHikariPool.java:182)</span><br><span class="line">  at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:93)</span><br><span class="line">  at slick.jdbc.hikaricp.HikariCPJdbcDataSource.createConnection(HikariCPJdbcDataSource.scala:12)</span><br><span class="line">  at slick.jdbc.JdbcBackend$BaseSession.conn$lzycompute(JdbcBackend.scala:415)</span><br><span class="line">  - locked &lt;merged&gt;(a slick.jdbc.JdbcBackend$BaseSession)</span><br><span class="line">  at slick.jdbc.JdbcBackend$BaseSession.conn(JdbcBackend.scala:414)</span><br><span class="line">  at slick.jdbc.JdbcBackend$BaseSession.startInTransaction(JdbcBackend.scala:437)</span><br><span class="line">  at slick.driver.JdbcActionComponent$StartTransaction$.run(JdbcActionComponent.scala:41)</span><br><span class="line">  at slick.driver.JdbcActionComponent$StartTransaction$.run(JdbcActionComponent.scala:38)</span><br><span class="line">  at slick.backend.Dat    abaseComponent$DatabaseDef$$anon$2.liftedTree1$1(DatabaseComponent.scala:237)</span><br><span class="line">  at slick.backend.DatabaseComponent$DatabaseDef$$anon$2.run(DatabaseComponent.scala:237)</span><br><span class="line">  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">  at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">  Locked ownable synchronizers:- &lt;merged&gt;(a java.util.concurrent.ThreadPoolExecutor$Worker)</span><br></pre></td></tr></table></figure><ul><li><p><code>java.io.BufferedInputStream</code>  </p><ul><li>线程阻塞在IO上,其他线程一直在获取数据库连接</li></ul></li><li><p><code>com.zaxxer.hikari.pool.BaseHikariPool.getConnection(BaseHikariPool.java:201)</code></p><ul><li>猜测原因是部分线程开启事物但是没提交,占着数据库连接资源不放,导致后续的db操作尝试获取db连接,还一直都拿不到,就造成了阻塞现象</li></ul></li></ul></li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们看 action.transactionally 实际返回的是一个链式的 DBIOAction</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SynchronousDatabaseAction</span>.fuseUnsafe(</span><br><span class="line">  <span class="type">StartTransaction</span>.andThen(a).cleanUp(eo =&gt; <span class="keyword">if</span>(eo.isEmpty) <span class="type">Commit</span> <span class="keyword">else</span> <span class="type">Rollback</span>)(<span class="type">DBIO</span>.sameThreadExecutionContext)</span><br><span class="line">    .asInstanceOf[<span class="type">DBIOAction</span>[<span class="type">R</span>, <span class="type">S</span>, <span class="type">E</span> <span class="keyword">with</span> <span class="type">Effect</span>.<span class="type">Transactional</span>]]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中的 a 就是下面的 action db真实的操作语句</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> action = &#123;testTable += i&#125;</span><br><span class="line">.flatMap &#123; _ =&gt; testTable.length.result &#125;</span><br><span class="line">.flatMap &#123; _ =&gt; <span class="type">DBIO</span>.successful(<span class="string">s&quot;insert successfully <span class="subst">$i</span>&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><p>最后以StartTransaction为开头的以CleanUpAction为结尾DBIOAction链,走到递归方法<br><code>runInContext[R](a: DBIOAction[R, NoStream, Nothing], ctx: Context, streaming: Boolean, topLevel: Boolean): Future[R]</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">runInContext</span></span>[<span class="type">R</span>](a: <span class="type">DBIOAction</span>[<span class="type">R</span>, <span class="type">NoStream</span>, <span class="type">Nothing</span>], ctx: <span class="type">Context</span>, streaming: <span class="type">Boolean</span>, topLevel: <span class="type">Boolean</span>): <span class="type">Future</span>[<span class="type">R</span>] = &#123;</span><br><span class="line">  logAction(a, ctx)</span><br><span class="line">  a <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">SuccessAction</span>(v) =&gt; <span class="type">Future</span>.successful(v)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">FailureAction</span>(t) =&gt; <span class="type">Future</span>.failed(t)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">FutureAction</span>(f) =&gt; f</span><br><span class="line">    <span class="keyword">case</span> <span class="type">FlatMapAction</span>(base, f, ec) =&gt;</span><br><span class="line">      runInContext(base, ctx, <span class="literal">false</span>, topLevel).flatMap(v =&gt; runInContext(f(v), ctx, streaming, <span class="literal">false</span>))(ctx.getEC(ec))</span><br><span class="line">    <span class="keyword">case</span> <span class="type">AndThenAction</span>(actions) =&gt;</span><br><span class="line">      <span class="keyword">val</span> last = actions.length - <span class="number">1</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(pos: <span class="type">Int</span>, v: <span class="type">Any</span>): <span class="type">Future</span>[<span class="type">Any</span>] = &#123;</span><br><span class="line">        <span class="keyword">val</span> f1 = runInContext(actions(pos), ctx, streaming &amp;&amp; pos == last, pos == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(pos == last) f1</span><br><span class="line">        <span class="keyword">else</span> f1.flatMap(run(pos + <span class="number">1</span>, _))(<span class="type">DBIO</span>.sameThreadExecutionContext)</span><br><span class="line">      &#125;</span><br><span class="line">      run(<span class="number">0</span>, <span class="literal">null</span>).asInstanceOf[<span class="type">Future</span>[<span class="type">R</span>]]</span><br><span class="line">    <span class="keyword">case</span> sa @ <span class="type">SequenceAction</span>(actions) =&gt;</span><br><span class="line">      <span class="keyword">val</span> len = actions.length</span><br><span class="line">      <span class="keyword">val</span> results = <span class="keyword">new</span> <span class="type">AtomicReferenceArray</span>[<span class="type">Any</span>](len)</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(pos: <span class="type">Int</span>): <span class="type">Future</span>[<span class="type">Any</span>] = &#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == len) <span class="type">Future</span>.successful &#123;</span><br><span class="line">          <span class="keyword">val</span> b = sa.cbf()</span><br><span class="line">          <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">          <span class="keyword">while</span>(i &lt; len) &#123;</span><br><span class="line">            b += results.get(i)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">          b.result()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> runInContext(actions(pos), ctx, <span class="literal">false</span>, pos == <span class="number">0</span>).flatMap &#123; (v: <span class="type">Any</span>) =&gt;</span><br><span class="line">          results.set(pos, v)</span><br><span class="line">          run(pos + <span class="number">1</span>)</span><br><span class="line">        &#125; (<span class="type">DBIO</span>.sameThreadExecutionContext)</span><br><span class="line">      &#125;</span><br><span class="line">      run(<span class="number">0</span>).asInstanceOf[<span class="type">Future</span>[<span class="type">R</span>]]</span><br><span class="line">    <span class="keyword">case</span> <span class="type">CleanUpAction</span>(base, f, keepFailure, ec) =&gt;</span><br><span class="line">      <span class="keyword">val</span> p = <span class="type">Promise</span>[<span class="type">R</span>]()</span><br><span class="line">      runInContext(base, ctx, streaming, topLevel).onComplete &#123; t1 =&gt;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">val</span> a2 = f(t1 <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">Success</span>(_) =&gt; <span class="type">None</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">Failure</span>(t) =&gt; <span class="type">Some</span>(t)</span><br><span class="line">          &#125;)</span><br><span class="line">          runInContext(a2, ctx, <span class="literal">false</span>, <span class="literal">false</span>).onComplete &#123; t2 =&gt;</span><br><span class="line">            <span class="keyword">if</span>(t2.isFailure &amp;&amp; (t1.isSuccess || !keepFailure)) p.complete(t2.asInstanceOf[<span class="type">Failure</span>[<span class="type">R</span>]])</span><br><span class="line">            <span class="keyword">else</span> p.complete(t1)</span><br><span class="line">          &#125; (<span class="type">DBIO</span>.sameThreadExecutionContext)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">NonFatal</span>(ex) =&gt;</span><br><span class="line">            <span class="keyword">throw</span> (t1 <span class="keyword">match</span> &#123;</span><br><span class="line">              <span class="keyword">case</span> <span class="type">Failure</span>(t) <span class="keyword">if</span> keepFailure =&gt; t</span><br><span class="line">              <span class="keyword">case</span> _ =&gt; ex</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; (ctx.getEC(ec))</span><br><span class="line">      p.future</span><br><span class="line">    <span class="keyword">case</span> <span class="type">FailedAction</span>(a) =&gt;</span><br><span class="line">      runInContext(a, ctx, <span class="literal">false</span>, topLevel).failed.asInstanceOf[<span class="type">Future</span>[<span class="type">R</span>]]</span><br><span class="line">    <span class="keyword">case</span> <span class="type">AsTryAction</span>(a) =&gt;</span><br><span class="line">      <span class="keyword">val</span> p = <span class="type">Promise</span>[<span class="type">R</span>]()</span><br><span class="line">      runInContext(a, ctx, <span class="literal">false</span>, topLevel).onComplete(v =&gt; p.success(v.asInstanceOf[<span class="type">R</span>]))(<span class="type">DBIO</span>.sameThreadExecutionContext)</span><br><span class="line">      p.future</span><br><span class="line">    <span class="keyword">case</span> <span class="type">NamedAction</span>(a, _) =&gt;</span><br><span class="line">      runInContext(a, ctx, streaming, topLevel)</span><br><span class="line">    <span class="keyword">case</span> a: <span class="type">SynchronousDatabaseAction</span>[_, _, _, _] =&gt;</span><br><span class="line">      <span class="keyword">if</span>(streaming) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.supportsStreaming) streamSynchronousDatabaseAction(a.asInstanceOf[<span class="type">SynchronousDatabaseAction</span>[_, _ &lt;: <span class="type">NoStream</span>, <span class="type">This</span>, _ &lt;: <span class="type">Effect</span>]], ctx.asInstanceOf[<span class="type">StreamingContext</span>], !topLevel).asInstanceOf[<span class="type">Future</span>[<span class="type">R</span>]]</span><br><span class="line">        <span class="keyword">else</span> runInContext(<span class="type">CleanUpAction</span>(<span class="type">AndThenAction</span>(<span class="type">Vector</span>(<span class="type">DBIO</span>.<span class="type">Pin</span>, a.nonFusedEquivalentAction)), _ =&gt; <span class="type">DBIO</span>.<span class="type">Unpin</span>, <span class="literal">true</span>, <span class="type">DBIO</span>.sameThreadExecutionContext), ctx, streaming, topLevel)</span><br><span class="line">      &#125; <span class="keyword">else</span> runSynchronousDatabaseAction(a.asInstanceOf[<span class="type">SynchronousDatabaseAction</span>[<span class="type">R</span>, <span class="type">NoStream</span>, <span class="type">This</span>, _]], ctx, !topLevel)</span><br><span class="line">    <span class="keyword">case</span> a: <span class="type">DatabaseAction</span>[_, _, _] =&gt;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SlickException</span>(<span class="string">s&quot;Unsupported database action <span class="subst">$a</span> for <span class="subst">$this</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CleanUpAction(base, f, keepFailure, ec) 中的 f 就是 <code>eo =&gt; if(eo.isEmpty) Commit else Rollback</code><br>根据是否有异常来决定 Commit 或是 Rollback<br><code>runSynchronousDatabaseAction(a.asInstanceOf[SynchronousDatabaseAction[R,NoStream,This,_]],ctx,!topLevel)</code> 的逻辑是将任务提交到线程池中去执行<br>先申请连接，然后在执行自己内部的 run 方法，释放连接</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">runSynchronousDatabaseAction</span></span>[<span class="type">R</span>](a: <span class="type">SynchronousDatabaseAction</span>[<span class="type">R</span>, <span class="type">NoStream</span>, <span class="type">This</span>, _], ctx: <span class="type">Context</span>, highPrio: <span class="type">Boolean</span>): <span class="type">Future</span>[<span class="type">R</span>] = &#123;</span><br><span class="line">  <span class="keyword">val</span> promise = <span class="type">Promise</span>[<span class="type">R</span>]()</span><br><span class="line">  ctx.getEC(synchronousExecutionContext).prepare.execute(<span class="keyword">new</span> <span class="type">AsyncExecutor</span>.<span class="type">PrioritizedRunnable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">highPriority</span> </span>= highPrio</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>: <span class="type">Unit</span> =</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ctx.sync</span><br><span class="line">        <span class="keyword">val</span> res = <span class="keyword">try</span> &#123;</span><br><span class="line">          acquireSession(ctx)</span><br><span class="line">          <span class="keyword">val</span> res = <span class="keyword">try</span> a.run(ctx) <span class="keyword">catch</span> &#123; <span class="keyword">case</span> <span class="type">NonFatal</span>(ex) =&gt;</span><br><span class="line">            releaseSession(ctx, <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">throw</span> ex</span><br><span class="line">          &#125;</span><br><span class="line">          releaseSession(ctx, <span class="literal">false</span>)</span><br><span class="line">          res</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; ctx.sync = <span class="number">0</span> &#125;</span><br><span class="line">        promise.success(res)</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123; <span class="keyword">case</span> <span class="type">NonFatal</span>(ex) =&gt; promise.tryFailure(ex) &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  promise.future</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>多个以<code>StartTransaction</code>为开头的以<code>CleanUpAction</code>为结尾的<code>DBIOAction</code>链提交到线程池里面去，线程池内都是与DB交互的IO阻塞性任务<br>具有事务提交逻辑的<code>CleanUpAction</code> 在 DBIOAction链的末尾，极有可能拿不到线程池中的优先执行权限,占着线程池内的资源的其他线程没有事务提交,不会释放掉DB连接。<br>造成数据库连接池连接资源紧张,其他线程就一直处在申请连接的阻塞状态</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul><li>slick 默认的数据库连接池选择的是 <code>HikariCP</code></li><li>numThread的配置同样也是数据库连接池里面默认的 <code>db</code> 最小连接数的配置</li></ul>]]></content>
      
      
      <categories>
          
          <category> scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> slick </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala Future 异步工具类解读</title>
      <link href="2019/03/30/scala-future.html"/>
      <url>2019/03/30/scala-future.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>将任务提交到线程池，来达到异步执行到效果</p><h2 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>先看一个 Future 用法的 例子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Future</span> &#123; println(<span class="string">&quot;start future&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><p>在 scala 的语法里，以下三种写法作用一样</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Future</span> &#123;&#125;</span><br><span class="line"><span class="type">Future</span> ()</span><br><span class="line"><span class="type">Future</span>.apply()</span><br></pre></td></tr></table></figure><p>进入到 Future.apply 方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](body: =&gt;<span class="type">T</span>)(<span class="keyword">implicit</span> <span class="meta">@deprecatedName</span>(<span class="symbol">&#x27;execctx</span>) executor: <span class="type">ExecutionContext</span>): <span class="type">Future</span>[<span class="type">T</span>] =</span><br><span class="line">    unit.map(_ =&gt; body)</span><br></pre></td></tr></table></figure><p>unit 为</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> unit: <span class="type">Future</span>[<span class="type">Unit</span>] = successful(())</span><br></pre></td></tr></table></figure><p>再看 successful</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">successful</span></span>[<span class="type">T</span>](result: <span class="type">T</span>): <span class="type">Future</span>[<span class="type">T</span>] = <span class="type">Promise</span>.successful(result).future</span><br></pre></td></tr></table></figure><p>进入到 Promise.successful()</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">successful</span></span>[<span class="type">T</span>](result: <span class="type">T</span>): <span class="type">Promise</span>[<span class="type">T</span>] = fromTry(<span class="type">Success</span>(result))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fromTry</span></span>[<span class="type">T</span>](result: <span class="type">Try</span>[<span class="type">T</span>]): <span class="type">Promise</span>[<span class="type">T</span>] = impl.<span class="type">Promise</span>.<span class="type">KeptPromise</span>[<span class="type">T</span>](result)</span><br></pre></td></tr></table></figure><p>进入到 Promise.KeptPromise,</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](result: <span class="type">Try</span>[<span class="type">T</span>]): scala.concurrent.<span class="type">Promise</span>[<span class="type">T</span>] =</span><br><span class="line">  resolveTry(result) <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> s @ <span class="type">Success</span>(_) =&gt; <span class="keyword">new</span> <span class="type">Successful</span>(s)</span><br><span class="line">    <span class="keyword">case</span> f @ <span class="type">Failure</span>(_) =&gt; <span class="keyword">new</span> <span class="type">Failed</span>(f)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最终构造了一个 Kept 对象 <strong>Kept 是 Promise 的子类，Promise 是 Future 的子类</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Kept</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="type">Promise</span>[<span class="type">T</span>] </span><br><span class="line"><span class="type">Promise</span>[<span class="type">T</span>] <span class="keyword">extends</span> scala.concurrent.<span class="type">Promise</span>[<span class="type">T</span>] <span class="keyword">with</span> scala.concurrent.<span class="type">Future</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure><h3 id="执行任务-body-gt-T"><a href="#执行任务-body-gt-T" class="headerlink" title="执行任务  body: =&gt; T"></a>执行任务  <code>body: =&gt; T</code></h3><p>我们重回 Future.apply, 看看 unit.map(_ =&gt; body) 的逻辑</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">S</span>](f: <span class="type">T</span> =&gt; <span class="type">S</span>)(<span class="keyword">implicit</span> executor: <span class="type">ExecutionContext</span>): <span class="type">Future</span>[<span class="type">S</span>] = transform(_ map f)</span><br></pre></td></tr></table></figure><p>transform是一个抽象方法，所以我们去看 子类 Promise.transform 的实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">Future</span></span><br><span class="line"><span class="keyword">import</span> scala.concurrent.impl.<span class="type">Promise</span>.<span class="type">DefaultPromise</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>[<span class="type">S</span>](f: <span class="type">Try</span>[<span class="type">T</span>] =&gt; <span class="type">Try</span>[<span class="type">S</span>])(<span class="keyword">implicit</span> executor: <span class="type">ExecutionContext</span>): <span class="type">Future</span>[<span class="type">S</span>] = &#123;</span><br><span class="line">  <span class="keyword">val</span> p = <span class="keyword">new</span> <span class="type">DefaultPromise</span>[<span class="type">S</span>]() </span><br><span class="line">  onComplete &#123; result =&gt; p.complete(<span class="keyword">try</span> f(result) <span class="keyword">catch</span> &#123; <span class="keyword">case</span> <span class="type">NonFatal</span>(t) =&gt; <span class="type">Failure</span>(t) &#125;) &#125;</span><br><span class="line">  p.future</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据 DefaultPromise 类的定义</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultPromise</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="title">AtomicReference</span>[<span class="type">AnyRef</span>](<span class="params"><span class="type">Nil</span></span>) <span class="keyword">with</span> <span class="title">Promise</span>[<span class="type">T</span>]</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">p</span> </span>= <span class="keyword">new</span> <span class="type">DefaultPromise</span>[<span class="type">S</span>]() </span><br><span class="line">实际上是初始化了一个 <span class="type">AtomicReference</span>[<span class="type">AnyRef</span>](空的list)</span><br><span class="line"><span class="type">Nil</span> = <span class="type">List</span>.empty</span><br></pre></td></tr></table></figure><p>接着我们看 DefaultPromise.onComplete 的实现, <strong>DefaultPromise 是 AtomicReference <code>无锁的对象引用</code> 的子类</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">onComplete</span></span>[<span class="type">U</span>](func: <span class="type">Try</span>[<span class="type">T</span>] =&gt; <span class="type">U</span>)(<span class="keyword">implicit</span> executor: <span class="type">ExecutionContext</span>): <span class="type">Unit</span> = dispatchOrAddCallback(<span class="keyword">new</span> <span class="type">CallbackRunnable</span>[<span class="type">T</span>](executor.prepare(), func))</span><br><span class="line"></span><br><span class="line"><span class="meta">@tailrec</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">dispatchOrAddCallback</span></span>(runnable: <span class="type">CallbackRunnable</span>[<span class="type">T</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  get() <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> r: <span class="type">Try</span>[_]          =&gt; runnable.executeWithValue(r.asInstanceOf[<span class="type">Try</span>[<span class="type">T</span>]])</span><br><span class="line">    <span class="keyword">case</span> dp: <span class="type">DefaultPromise</span>[_] =&gt; compressedRoot(dp).dispatchOrAddCallback(runnable)</span><br><span class="line">    <span class="keyword">case</span> listeners: <span class="type">List</span>[_] =&gt; <span class="keyword">if</span> (compareAndSet(listeners, runnable :: listeners)) ()</span><br><span class="line">                                <span class="keyword">else</span> dispatchOrAddCallback(runnable)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终 runable.executeWithValue 执行，也就是 <code>CallbackRunnable.executeWithValue</code> 提交任务到线程池去执行 </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackRunnable</span>[<span class="type">T</span>](<span class="params">val executor: <span class="type">ExecutionContext</span>, val onComplete: <span class="type">Try</span>[<span class="type">T</span>] =&gt; <span class="type">Any</span></span>) <span class="keyword">extends</span> <span class="title">Runnable</span> <span class="keyword">with</span> <span class="title">OnCompleteRunnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// must be filled in before running it</span></span><br><span class="line">  <span class="keyword">var</span> value: <span class="type">Try</span>[<span class="type">T</span>] = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() = &#123;</span><br><span class="line">    require(value ne <span class="literal">null</span>) <span class="comment">// must set value to non-null before running!</span></span><br><span class="line">    <span class="keyword">try</span> onComplete(value) <span class="keyword">catch</span> &#123; <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt; executor reportFailure e &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">executeWithValue</span></span>(v: <span class="type">Try</span>[<span class="type">T</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    require(value eq <span class="literal">null</span>) <span class="comment">// can&#x27;t complete it twice</span></span><br><span class="line">    value = v</span><br><span class="line">    <span class="comment">// Note that we cannot prepare the ExecutionContext at this point, since we might</span></span><br><span class="line">    <span class="comment">// already be running on a different thread!</span></span><br><span class="line">    <span class="keyword">try</span> executor.execute(<span class="keyword">this</span>) <span class="keyword">catch</span> &#123; <span class="keyword">case</span> <span class="type">NonFatal</span>(t) =&gt; executor reportFailure t &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看callbackRunnalbe的定义, 函数onComplete的实现为 Promise.transform 的实现中的代码 </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result =&gt; p.complete(<span class="keyword">try</span> f(result) <span class="keyword">catch</span> &#123; <span class="keyword">case</span> <span class="type">NonFatal</span>(t) =&gt; <span class="type">Failure</span>(t) &#125;)</span><br></pre></td></tr></table></figure><p>最后 p.complete 会返回一个 Promise 对象也就是 Future对象本身</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">complete</span></span>(result: <span class="type">Try</span>[<span class="type">T</span>]): <span class="keyword">this</span>.<span class="keyword">type</span> =</span><br><span class="line">    <span class="keyword">if</span> (tryComplete(result)) <span class="keyword">this</span> <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">&quot;Promise already completed.&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Future 执行流程</p><ul><li>创建Future 交给 Promise 对象管理，并将线程池引用传入到 Promise 对象中</li><li>Promise 对 Future 里的任务进行调度执行</li></ul>]]></content>
      
      
      <categories>
          
          <category> scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
            <tag> future </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
